
;FIXED? : make handle -> dword
;OP.TBL pnt WORD -> DWORD
;TODO:
;ERR_CONT:
;	CALL	ERRSUB
;	MOV	ESP,[STACK]	<- ok?
;

;remove ".reloc" section

	ORG	00400000h

BASE:

;http://msdn.microsoft.com/en-us/library/ms809762.aspx
;HelloWorld_Con.exe

PE_OFFSET EQU	000000C0H

;must be aligned
;DATA_ADD EQU 8000h+8000h+20000h
;DATA_ADD EQU 1000h+4000h+0f0000h
DATA_ADD EQU 1000h+4000h	;R.BUF+W.BUF	;+0f0000h

;TODO: get ride of ".reloc" section?
;TODO: make same alignment
;FILE_ALIGN EQU	200h
FILE_ALIGN EQU	1000h	;##
SECTION_ALIGN EQU	1000h
;SECTION_ALIGN EQU	200h	;##

;_TEXT_RVA EQU	1000h
;_RDATA_RVA EQU	2000h
;_DATA_RVA EQU	3000h
;_RELOC_RVA EQU	4000h

_TEXT_RVA EQU	_TEXT-BASE
_RDATA_RVA EQU	_RDATA-BASE
_DATA_RVA EQU	_DATA-BASE
;_RELOC_RVA EQU	_RELOC-BASE+DATA_ADD


_RDATA_SIZE EQU	_RDATA_END-_RDATA
_DATA_SIZE EQU	_DATA_END-_DATA+DATA_ADD
;_RELOC_SIZE EQU _RELOC_END-_RELOC
_RELOC_SIZE EQU 0

CODE_SIZE EQU	_TEXT_END-_TEXT
INIT_DATA_SIZE EQU	_RDATA_SIZE+_DATA_SIZE+_RELOC_SIZE
UNINIT_DATA_SIZE EQU	0

;BASE_SIZE EQU	_RELOC_RVA+SECTION_ALIGN	;_RELOC_SIZE
BASE_SIZE EQU	_DATA_RVA+_DATA_SIZE	;SECTION_ALIGN	;_RELOC_SIZE

ENTRY_RVA EQU	_TEXT_RVA


HEADER:
	DB	'M','Z'
	DW	0090h	;Bytes on last page of file
	DW	0003h	;Pages in file
	DW	0000h	;Relocations
	DW	0004h	;Size of header in paragraphs
	DW	0000h	;Minimum extra paragraphs needed
	DW	0FFFFh	;Maximum extra paragraphs needed
	DW	0000h	;Initial (relative) SS value

;+10
	DW	00B8h	;Initial SP value
	DW	0000h	;Checksum
	DW	0000h	;Initial IP value
	DW	0000h	;Initial (relative) CS value
	DW	0040h	;File address of relocation table
	DW	0000h	;Overlay number
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words

;+20
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words
	DW	0000h	;OEM identifier (for e_oeminfo)
	DW	0000h	;OEM information; e_oemid specific
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words
;+30
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words
	DW	0000h	;Reserved words
;+3c
	DD	PE_OFFSET	;000000C0H	;DW	00C0H, 0000h	;File address of new exe header
;+40
	DB	0Eh, 1Fh,0BAh, 0Eh, 00h,0B4h, 09h,0CDh
	DB	21h,0B8h, 01h, 4Ch,0CDh, 21h, 54h, 68h
	DB	69h, 73h, 20h, 70h, 72h, 6Fh, 67h, 72h
	DB	61h, 6Dh, 20h, 63h, 61h, 6Eh, 6Eh, 6Fh
	DB	74h, 20h, 62h, 65h, 20h, 72h, 75h, 6Eh
	DB	20h, 69h, 6Eh, 20h, 44h, 4Fh, 53h, 20h
	DB	6Dh, 6Fh, 64h, 65h, 2Eh, 0Dh, 0Dh, 0Ah
	DB	24h, 00h, 00h, 00h, 00h, 00h, 00h, 00h


	;PUSH	CS
	;POP	DS
	;MOV	DX,MES_DUMMY-HEADER-40H
	;MOV	AH,9
	;INT	21H
	;MOV	AX,4C01H
	;INT	21H
;MES_DUMMY:
	;DB	"This program cannot be run in DOS mode.", 0dh, 0dh, 0ah, '$'

;+80
	

	;DS	HEADER+0c0h-$
	DS	BASE+PE_OFFSET-$

;+c0
	DB	'P','E', 00h, 00h
	DW	014ch		;Machine	= IMAGE_FILE_MACHINE_I386
	DW	0003h	;0004h		;NumberOfSections
	DD	529037aeh	;TimeDateStamp
	DD	00000000h	;PointerToSymbolTable
;+d0
	DD	00000000h	;NumberOfSymbols
	DW	00E0h		;SizeOfOptionalHeader
	DW	0102h		;Characteristics = IMAGE_FILE_32BIT_MACHINE(0x0100)
				;		| IMAGE_FILE_EXECUTABLE_IMAGE(0x0002)
;+d8
	DW	010Bh		;Magic
	DB	09h	;MajorLinkerVersion
	DB	00h	;MinorLinkerVersion
	DD	CODE_SIZE	;00000200h	;SizeOfCode
;+e0
	DD	INIT_DATA_SIZE	;00000600h	;SizeOfInitializedData
	DD	UNINIT_DATA_SIZE	;00000000h	;SizeOfUninitializedData
	DD	ENTRY_RVA	;00001000h	;AddressOfEntryPoint
	DD	_TEXT_RVA	;00001000h	;BaseOfCode
;+f0
	DD	_RDATA_RVA	;00002000h	;BaseOfData
	DD	BASE	;00400000h	;ImageBase
	DD	SECTION_ALIGN	;00001000h	;SectionAlignment

	DD	FILE_ALIGN	;00000200h	;FileAlignment
;+100
	DW	0005h	;MajorOperatingSystemVersion
	DW	0000h	;MinorOperatingSystemVersion
	DW	0000h	;MajorImageVersion
	DW	0000h	;MinorImageVersion
	DW	0005h	;MajorSubsystemVersion
	DW	0000h	;MinorSubsystemVersion
	DD	00000000h	;Win32VersionValue
;+110
	DD	BASE_SIZE	;00005000h	;SizeOfImage
	DD	_TEXT-BASE	;00000400h	;SizeOfHeaders
	DD	00000000h	;CheckSum
	DW	0003h		;Subsystem = IMAGE_SUBSYSTEM_WINDOWS_CUI(3)

;IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
;IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.


	;DW	8540h		;DllCharacteristics
	;DW	8500h
	;DW	8000h
	DW	0
				;
				;IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040     // DLL can move.
				;IMAGE_DLLCHARACTERISTICS_NX_COMPAT    0x0100     // Image is NX compatible
				;IMAGE_DLLCHARACTERISTICS_NO_SEH       0x0400     // Image does not use SEH.  No SE handler may reside in this image
				;IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE     0x8000

;IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY    0x0080     // Code Integrity Image


;+120
	DD	00100000h	;SizeOfStackReserve
	DD	00001000h	;SizeOfStackCommit
	DD	00100000h	;SizeOfHeapReserve
	DD	00001000h	;SizeOfHeapCommit
;+130
	DD	00000000h	;LoaderFlags
	DD	00000010h	;NumberOfRvaAndSizes

;+138
	DD	00000000h	;#0
	DD	00000000h
;+140
	DD	ENTRY_IMPORT-_RDATA+_RDATA_RVA	;0000200ch	;#1 IMAGE_DIRECTORY_ENTRY_IMPORT
	DD	ENTRY_IMPORT_END-ENTRY_IMPORT	;00000028h
	DD	00000000h	;#2 IMAGE_DIRECTORY_ENTRY_RESOURCE
	DD	00000000h
;+150
	DD	00000000h	;#3
	DD	00000000h
	DD	00000000h	;#4
	DD	00000000h
;+160
	DD	0	;00004000h	;#5 IMAGE_DIRECTORY_ENTRY_BASERELOC
	DD	0	;00000010h
	DD	00000000h	;#6 IMAGE_DIRECTORY_ENTRY_DEBUG
	DD	00000000h
;+170
	DD	00000000h	;#7
	DD	00000000h
	DD	00000000h	;#8
	DD	00000000h
;+180
	DD	00000000h	;#9
	DD	00000000h
	DD	00000000h	;#a
	DD	00000000h
;+190
	DD	00000000h	;#b
	DD	00000000h
	DD	_RDATA_RVA	;00002000h	;#c IMAGE_DIRECTORY_ENTRY_IAT
	DD	ENTRY_IAT_END-ENTRY_IAT	;0000000ch
;+1a0
	DD	00000000h	;#d
	DD	00000000h
	DD	00000000h	;#e
	DD	00000000h
;+1b0
	DD	00000000h	;#f
	DD	00000000h

;section header
;+1b8	(c0('PE') + f8)
	DB	".text",0,0,0
	DD	_TEXT_FILL-_TEXT	;0000001dh	;adrs/size
	DD	_TEXT_RVA	;00001000h	;VirtualAddress
	DD	_TEXT_END-_TEXT	;00000200h	;SizeOfRawData
	DD	_TEXT-BASE	;00000400h	;PointerToRawData
	DD	00000000h	;PointerToRelocations
	DD	00000000h	;PointerToLinenumbers
	DW	0000h		;NumberOfRelocations
	DW	0000h		;NumberOfLinenumbers
	DD	60000020h	;Characteristics
	;DD	60000020h+80000000h	;Characteristics
	;	IMAGE_SCN_CNT_CODE	(00000020)
	;	| IMAGE_SCN_MEM_EXECUTE	(20000000)
	;	| IMAGE_SCN_MEM_READ	(40000000)
;+1e0
	DB	".rdata", 0,0
	DD	_RDATA_FILL-_RDATA	;0000006ah
	DD	_RDATA_RVA	;00002000h	;VirtualAddress
	DD	_RDATA_END-_RDATA	;00000200h	;SizeOfRawData
	DD	_RDATA-BASE	;00000600h	;PointerToRawData
	DD	00000000h
	DD	00000000h
	DW	0000h
	DW	0000h
	DD	40000040h
	;	IMAGE_SCN_CNT_INITIALIZED_DATA	(00000040)
	;	| IMAGE_SCN_MEM_READ		(40000000)

;+208
	DB	".data",0,0,0
	DD	DATA_ADD+_DATA_FILL-_DATA	;0000000fh
	DD	_DATA_RVA	;00003000h	;VirtualAddress
	DD	_DATA_END-_DATA	;00000200h	;SizeOfRawData
	DD	_DATA-BASE	;00000800h	;PointerToRawData
	DD	00000000h
	DD	00000000h
	DW	0000h
	DW	0000h
	DD	0c0000040h
	;	IMAGE_SCN_CNT_INITIALIZED_DATA(00000040)
	;	| IMAGE_SCN_MEM_READ	(40000000)
	;	| IMAGE_SCN_MEM_WRITE	(80000000)
;;+230
;	DB	".reloc",0,0
;	DD	_RELOC_FILL-_RELOC	;00000028h
;	DD	_RELOC_RVA	;00004000h	;VirtualAddress
;	DD	_RELOC_END-_RELOC	;00000200h	;SizeOfRawData
;	DD	_RELOC-BASE	;00000a00h	;PointerToRawData
;	DD	00000000h
;	DD	00000000h
;	DW	0000h
;	DW	0000h
;	DD	42000040h
;	;	IMAGE_SCN_CNT_INITIALIZED_DATA	(00000040)
;	;	| IMAGE_SCN_MEM_DISCARDABLE	(02000000)
;	;	| IMAGE_SCN_MEM_READ		(40000000)


;#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.

;+258



	;ds	HEADER+0400h-$
	ALIGN	FILE_ALIGN

_TEXT:

;+400	".text"

	PUSH	DWORD -10
	CALL	[IAT_GetStdHandle]
	MOV	[HDL_STDIN],EAX

	PUSH	DWORD -11
	CALL	[IAT_GetStdHandle]
	MOV	[HDL_STDOUT],EAX

	PUSH	DWORD -12
	CALL	[IAT_GetStdHandle]
	MOV	[HDL_STDERR],EAX

	CALL	[IAT_GetCommandLineA]
	MOV	[CMDLINE],EAX

	MOV	ESI,EAX
	CALL	_PUTSTR




	;JMP	TEST_HELLO

	;JMP	TEST2
	;JMP	TEST3
	;JMP	TEST4
	;JMP	TEST5
	;JMP	TEST6
	;JMP	TEST7

	JMP	A386_MAIN

	PUSH	DWORD -12;-11;	PUSH	0FFFFFFF5h
	;CALL	[IAT_GetStdHandle-_RDATA+_RDATA_RVA+BASE]	;CALL	[00402000h]
	CALL	[IAT_GetStdHandle]

	push	eax

	push	0
	push	N_WROTE	;0
	push	0eh
	;push	STR_HELLO-_DATA+_DATA_RVA+BASE	;00403000h
	push	STR_HELLO
	push	EAX
	;CALL	[IAT_WriteFile-_RDATA+_RDATA_RVA+BASE]	;;call	[00402004h]
	CALL	[IAT_WriteFile]

	pop	eax

	push	0
	mov	ebx,esp;	lea	eax,[esp+0]
	push	0
	push	ebx
	push	0eh
	push	STR_HELLO
	push	eax
	call	[IAT_WriteFile]

	pop	eax

;	XOR	EAX,EAX
	RET


TEST2:
	PUSH	DWORD -10
	CALL	[IAT_GetStdHandle]
	MOV	[HDL_STDIN],EAX

	PUSH	DWORD -11
	CALL	[IAT_GetStdHandle]
	MOV	[HDL_STDOUT],EAX


	PUSH	0
	PUSH	N_READ
	PUSH	100
	PUSH	READ_BUF
	PUSH	[HDL_STDIN]
	call	[IAT_ReadFile]

	PUSH	0
	PUSH	N_WROTE
	PUSH	[N_READ]
	PUSH	READ_BUF
	PUSH	[HDL_STDOUT]
	call	[IAT_WriteFile]

	MOV	EAX,[N_READ]

	RET


CREATE_NEW          EQU 1
CREATE_ALWAYS       EQU 2
OPEN_EXISTING       EQU 3
OPEN_ALWAYS         EQU 4
TRUNCATE_EXISTING   EQU 5

GENERIC_READ	EQU	80000000h
GENERIC_WRITE	EQU	40000000h
FILE_ATTRIBUTE_NORMAL EQU	00000080h

TEST3:
	PUSH	0		;templateFile
	PUSH	FILE_ATTRIBUTE_NORMAL
	PUSH	CREATE_ALWAYS	;CREATE_NEW
	PUSH	0		;securityAttribute
	PUSH	0		;shareMode
	PUSH	GENERIC_WRITE
	PUSH	FILENAME_TEST1
	CALL	[IAT_CreateFileA]
	MOV	[HDL_OUTFILE],EAX

	push	0
	push	N_WROTE	;0
	push	0eh
	push	STR_HELLO
	push	EAX
	CALL	[IAT_WriteFile]


	PUSH	[HDL_OUTFILE]
	CALL	[IAT_CloseHandle]

	RET


TEST4:
	CALL	[IAT_GetCommandLineA]
	MOV	[CMDLINE],EAX

	MOV	ESI,EAX
	CALL	_PUTSTR

	RET

TEST5:
	MOV	EBX,[IAT_ExitProcess]

	;CLI
	XOR	EAX,EAX
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	;MOV	SS,AX
	;MOV	ESP,_TEXT_FILL-4
	;STI

	PUSH	100
	PUSH	EBX
	RET

	MOV	EAX,100
	PUSH	EAX
	CALL	[IAT_ExitProcess]

	RET

TEST6:
	CALL	[IAT_GetCommandLineA]
	MOV	[CMDLINE],EAX

	MOV	ESI,EAX
	CALL	_PUTSTR

	MOV	EAX,[_DATA_FILL]


	MOV	EAX,[_TEXT]

	MOV	[_TEXT],EAX	;exception

	MOV	ESI,[CMDLINE]
	CALL	_PUTSTR

	RET

TEST_HELLO:
	MOV	ESI,STR_HELLO
	CALL	_PUTSTR
	RET

TEST7:
	MOV	EDI,USRDMA
	MOV	ECX,10000h
TEST7.10:
	MOV	[EDI],AL
	INC	EDI
	DEC	ECX
	JNE	TEST7.10

	CALL	TEST_HELLO
	MOV	AL,'7'
	CALL	_PUTCHR
	CALL	_PUTCRLF
	RET

_PUTCRLF:
	MOV	AL,0Dh
	CALL	_PUTCHR
	MOV	AL,0AH
	CALL	_PUTCHR
	RET

;
_PUTSTR:
	MOV	AL,[ESI]
	OR	AL,AL
	JE	_PUTSTR.R

	CALL	_PUTCHR

	INC	ESI
	JMP	_PUTSTR

_PUTSTR.R:
	RET

_PUTCHR:
	PUSHAD

	MOV	[PUTCHR_BUF],AL

	PUSH	0
	MOV	EAX,ESP

	push	0
	push	EAX	;push	N_WROTE	;0
	push	01h
	push	PUTCHR_BUF
	push	[HDL_STDOUT]
	CALL	[IAT_WriteFile]

	POP	EAX

	POPAD
	RET



GMEM_FIXED	EQU	00000000H
GMEM_ZEROINIT	EQU	00000040H

;	EAX<size
;	>EAX memory address

ALLOC:
	MOV	EBX,GMEM_FIXED+GMEM_ZEROINIT
	PUSH	EAX
	PUSH	EBX
	CALL	[IAT_GlobalAlloc]

	OR	EAX,EAX
	JE	ERR_ALLOC

	PUSHAD
	MOV	EBX,EAX
	CALL	PUTHEXD	;PUTH4
	POPAD

	RET

;	EAX<memory address

FREE:
	PUSH	EAX
	CALL	[IAT_GlobalFree]

	RET

;################

;;MEM_MAX_VALUE	EQU	USRDMA+0F0000h


;TODO
;	undefined label check

;
;EC13	use pointer link in info structure
;	prototype check
;	same name check

;
;	IF.MAKE	IF.PNT	80H->0
;

;
;	+0
;	+2 name
;	+4 link
;	+6 val
;	+8 val2
;	+10 type
;	+12 type2
;	+14 level
;	+16 func
;

W1	EQU	-4;-2
W2	EQU	-8;-4
W3	EQU	-12;-6
W4	EQU	-16;-8
W5	EQU	-20
W6	EQU	-24
W7	EQU	-28
W8	EQU	-32
W9	EQU	-36
W10	EQU	-40

NODESIZE EQU	14H*2	;8H*2	;20H
;NODESIZE_AST EQU 14H*2;6*2
NODESIZE_AST EQU 6*2

NODESIZE_ENUM_NAME EQU	14H*2
NODESIZE_ENUM_PARPAR EQU 10*2

MACROSIZE EQU	400H




R.BUF	EQU	1000h
W.BUF	EQU	4000H;1000H


;	:INFO
;;WORD_WORK_MACRO_PARAM EQU	USRDMA+R.BUF+W.BUF		;20000h
;;WORD_WORK_MACRO_PARAM_END EQU	WORD_WORK_MACRO_PARAM+0f000h	;2f000h

;;WORD_WORK_EXP		EQU	WORD_WORK_MACRO_PARAM_END+1000h	;30000h
;;WORD_WORK_EXP_END	EQU	WORD_WORK_EXP+0f000h		;3F000H

;;STRING_TBL EQU			WORD_WORK_EXP_END+1000h		;40000H
;;STRING_TBL_END EQU		STRING_TBL+6f00h		;57F00H


;;WORD_WORK_LABEL		EQU	STRING_TBL_END+100h		;58000H
;;WORD_WORK_LABEL_END	EQU	WORD_WORK_LABEL+10000h		;67F00H

;;WORD_WORK_MACRO	EQU		WORD_WORK_LABEL_END+100h	;68000H
;;WORD_WORK_MACRO_END EQU		WORD_WORK_MACRO+27000h		;8F000H

;;WORD_WORK_GLOBAL	EQU	WORD_WORK_MACRO_END+1000h		;090000H
;;WORD_WORK_GLOBAL_END	EQU	WORD_WORK_GLOBAL+38000h		;0C8000H


;WORD_WORK_MEMBER	EQU	0C0000H
;WORD_WORK_MEMBER_END	EQU	0C8000H

;;STRING_MACRO_TBL	EQU	WORD_WORK_GLOBAL_END+1000h	;0C9000H
;;STRING_MACRO_TBL_END	EQU	STRING_MACRO_TBL+20000h		;0E0000H


;;WORK_END	EQU	STRING_MACRO_TBL_END+1000h		;0E1000H

;

A386_MAIN:
	;ORG	0

	JMP	START

;
;
;

SETINT:
	PUSH	DS

	CLI
	MOV	AX,CS
	MOV	DS,AX
	MOV	EDX,INT00
	MOV	EBX,EDX
	MOV	AX,2504H
	MOV	CL,0
	CALL	INT21_setinterrupt	;INT	21H

	MOV	EDX,INT0D
	MOV	EBX,EDX
	MOV	AX,2504H
	MOV	CL,0DH
	CALL	INT21_setinterrupt	;INT	21H

	POP	DS
	STI
	RET

;

INT00:
	MOV	EDX,EMES_DIV
	MOV	AH,09H
	CALL	INT21_putstr	;INT	21H

	JMP	INT00

;

INT0D:
	CLI
	push	14h
	pop	ds
	mov	[dump_eax],eax
	mov	[dump_ebx],ebx

	mov	byte [flg.v],0ffh
	mov	byte [flg.d],0ffh

	MOV	EDX,EMES_PROT
	MOV	AH,09H
	CALL	INT21_putstr	;INT	21H

	mov	al,'b'
	call	putchr_con
	mov	eax,[dump_ebx]
	call	disp_ax
	mov	al,' '
	call	putchr_con

	MOV	EAX,ESP
	CALL	DISP_AX
	MOV	AL,'='
	CALL	PUTCHR_con

	MOV	EBP,ESP
	MOV	EAX,[EBP+0]
	CALL	DISP_AX
	MOV	AL,':'
	CALL	PUTCHR_CON
	MOV	EBP,ESP
	MOV	EAX,[EBP+4]
	CALL	DISP_AX
	MOV	AL,':'
	CALL	PUTCHR_CON
	MOV	EBP,ESP
	MOV	EAX,[EBP+8]
	CALL	DISP_AX

	JMP	INT0D



EMES_DIV:
	DB	'divided by 0$'


EMES_PROT:
	DB	'general protection$'

;
;
;

TITLE_MES:
	DB	'c compiler',0DH,0AH,'$'

START:
	PUSH	[FLG.D]

	MOV	BYTE [FLG.D],0FFH

	MOV	AH,9
	MOV	EDX,TITLE_MES
	CALL	INT21_putstr	;INT	21H

	CALL	INIT_MEMORY

	;xor	eax,eax
	;mov	ax,ds
	;db	0fh,03h,0c0h
	;;	MOV	EAX,MEM_MAX_VALUE
	;;MOV	[MEM_MAX],EAX
	;;mov	ebx,eax
	;;call	puthexd

		MOV	AH,2
		MOV	DL,'/'
		CALL	INT21_putchr	;INT	21H

		MOV	EBX,USRDMA
		ADD	EBX,R.BUF
		ADD	EBX,W.BUF
		CALL	PUTHEXD

	POP	[FLG.D]

	;;MOV	EAX,[MEM_MAX]
	;;SUB	EAX,100H
	;;AND	AL,0F0H
	;;MOV	[STACK],EAX

		;MOV	EAX,[STACK]
		;SUB	EAX,1000H
		;CMP	EAX,WORK_END
		;JBE	ERR_WORK

	;CALL	SETINT

;	MOV	AX,CS
;	MOV	ES,AX
;	MOV	AH,4AH		;modify
;	MOV	BX,1000H	;10000h/10h (64k)
;	INT	21H
;	JB	EXIT

;	MOV	AX,4800H	;alloc
;	MOV	BX,1000H
;	INT	21H
;	JB	ERR_ALLOC
;	MOV	CS:[STRING_MACRO_SEG],AX

;	MOV	AX,CS
;	MOV	DS,AX

	MOV	AX,DS
	MOV	ES,AX

	MOV	[STRING_MACRO_SEG],AX

;	MOV	AX,4800H	;alloc
;	MOV	BX,1000H
;	INT	21H
;	JB	EXIT
;	CLI
;;	MOV	AX,CS
;
;	MOV	SS,AX
;	MOV	SP,0FFFCH
;	STI

	;CLI
	;MOV	ESP,[STACK]	;MOV	ESP,10000H;80000H
	;STI

;	MOV	AX,CS
;	MOV	DS,AX
;	MOV	ES,AX
	CLD

	CALL	GETCLINE

	MOV	AL,[CLINE+1]
	CMP	AL,20H
	JBE	USAGE

	MOV	ESI,CLINE+1		;0082H
	MOV	EDI,FILE1
	CALL	STRCPY2

	MOV	ESI,FILE1
	MOV	EDI,FILE2
	CALL	STRCPY

		MOV	ESI,FILE1
		MOV	AL,'.'
		CALL	STRCHR
		OR	ESI,ESI
		JE	ADD_EXT

		MOV	BYTE [ESI],0

		PUSH	ESI
		MOV	ESI,FILE1
		MOV	EDI,FILE2
		CALL	STRCPY

		MOV	ESI,FILE2
		MOV	EDI,STR_ASM
		CALL	STRCAT
		POP	ESI
		MOV	BYTE [ESI],'.'
		JMP	ADD_EXT.E

ADD_EXT:
	MOV	ESI,FILE1
	MOV	EDI,STR_C
	CALL	STRCAT

	MOV	ESI,FILE2
	MOV	EDI,STR_ASM
	CALL	STRCAT

ADD_EXT.E:
		MOV	BYTE [FLG.3],0FFH
		MOV	BYTE [FLG.L],0FFH
		MOV	DWORD [TYPE_UINT],0004H
		MOV	DWORD [TYPE_INT],0084H

		MOV	DWORD [TYPE_PNT],0004H	;?

;	MOV	AX,WORD_TBL
	MOV	EAX,0
	MOV	[WORD_PNT],EAX	;<-

	;;MOV	EAX,STRING_MACRO_TBL
	MOV	EAX,[STRING_MACRO_TBL_INFO+0*4]
	MOV	[STRING_MACRO_PNT],EAX

	;;MOV	EAX,STRING_TBL
	MOV	EAX,[STRING_TBL_INFO+0*4]
	MOV	[STRING_PNT],EAX
	JMP	CHKLIN

MES_USAGE:
	DB	0DH,0AH
	DB	'Exp file Compiler',0DH,0AH
	DB	'	programmed by djnz80a',0DH,0AH
	DB	'run386 ec1 source [options]',0DH,0AH
	DB	0DH,0AH
	DB	'/v .. verbose',0DH,0AH
	DB	'/d .. debug',0DH,0AH
	DB	'/DNAME .. define',0DH,0AH
	DB	'/p .. preprocessing',0DH,0AH
	DB	'/m ,, memory listing on error',0DH,0AH
	DB	"/t .. test compile(don't make output)",0DH,0AH
	DB	'/oN .. optimize mode',0DH,0AH
	DB	'/l .. 32bit pointer',0DH,0AH
	DB	'/sN .. subfile label#',0DH,0AH
	DB	'/3 .. 386 mode',0DH,0AH
	DB	'/rX .. reference drive',0DH,0AH
	DB	'/n .. output name in comment',0DH,0AH
	DB	'/k .. k&r',0DH,0AH
	DB	'/u .. assume undefined func to be int',0DH,0AH
	DB	'/a .. register allocation',0DH,0AH
	DB	'/z .. output token',0DH,0AH
	DB	'/b .. bit field',0DH,0AH
	DB	'/+ .. c++ mode',0DH,0AH
	DB	'$'

CHKLIN:
	MOV	ESI,CLINE+1	;0081H
	CLD
SW:
	LODSB
	OR	AL,AL
	JE	SW90

	CMP	AL,'/'
	JNE	SW
	LODSB
	CALL	TOLOWER
	CMP	AL,'v'
	JNE	SW10
	MOV	BYTE [FLG.V],0FFH	;verbose
	JMP	SW

SW10:
	CMP	AL,'d'
	JNE	SW20

	CMP	BYTE [ESI-1],'D'
	JE	SW15
	MOV	BYTE [FLG.D],0FFH	;debug
	JMP	SW
SW15:
	CALL	PRE_DEFINE
	JMP	SW

SW20:
	CMP	AL,'p'
	JNE	SW30
	MOV	BYTE [FLG.P],0FFH
	JMP	SW

SW30:
	CMP	AL,'m'
	JNE	SW40
	MOV	BYTE [FLG.M],0FFH	;memory
	JMP	SW

SW40:
	CMP	AL,'t'
	JNE	SW50
	MOV	BYTE [PUTCHR],0C3H	;RET
	JMP	SW

SW50:
	CMP	AL,'o'
	JNE	SW60
	;MOV	BYTE [FLG.OPT],0FFH
	MOV	AL,[ESI]
	SUB	AL,'0'
	JB	SW50.10
	CMP	AL,10
	JNB	SW50.10

	CALL	GETHEX
	MOV	DWORD [FLG.OPT],EAX
	JMP	SW

SW50.10:
	MOV	DWORD [FLG.OPT],1
	JMP	SW



SW60:
	CMP	AL,'l'
	JNE	SW70
	MOV	BYTE [FLG.L],0FFH
	MOV	DWORD [TYPE_INT],0084H
	MOV	DWORD [TYPE_UINT],0004H
	MOV	DWORD [TYPE_PNT],0004H
	JMP	SW



SW70:
	CMP	AL,'s'	;sub
	JNE	SW80
	MOV	BYTE [FLG.S],0FFH
	CALL	GETHEX
	MOV	[LABEL_NO],EAX
	JMP	SW



SW80:
	CMP	AL,'3'
	JNE	SW81
	MOV	BYTE [FLG.3],0FFH
	MOV	DWORD [TYPE_PNT],0004H
	JMP	SW



SW81:	cmp	al,'r'
	jne	sw.82
	lodsb
	mov	[REF_DRV],al
	jmp	sw



sw.82:
	CMP	AL,'n'
	JNE	SW.83
	MOV	BYTE [FLG.N],01
	JMP	SW



SW.83:
	CMP	AL,'k'
	JNE	SW.84
	MOV	BYTE [FLG.K],0FFH	;K&R
	JMP	SW

SW.84:
	CMP	AL,'u'
	JNE	SW.85
	MOV	BYTE [FLG.U],0FFH
	JMP	SW



SW.85:
	CMP	AL,'a'
	JNE	SW.86
	MOV	BYTE [FLG.A],0FFH	;reg alloc
	JMP	SW



SW.86:
	CMP	AL,'z'
	JNE	SW.87
	MOV	BYTE [FLG.Z],0FFH	;out
;	PUSHAD
;	MOV	AX,3C00H
;	MOV	CX,0
;	MOV	EDX,FILE_OUT
;	INT	21H
;	MOV	[HDLOUT],AX
;	POPAD
	JMP	SW

FILE_OUT:DB	'D:\$OUT',0



SW.87:
	CMP	AL,'b'		;bitfield
	JNE	SW.88
	MOV	BYTE [FLG.B],0FFH
	JMP	SW


SW.88:
	CMP	AL,'+'
	JNE	SW.89
	MOV	BYTE [FLG.CPP],0FFH
	JMP	SW



SW.89:
	JMP	SW

SW90:
	MOV	EDX,FILE1
	MOV	AX,3D00H	;open
	CALL	INT21_open	;INT	21H
	JB	ERR_OPEN
	MOV	[HDL],AX

	MOV	WORD [HDL2],1	;dummy (stdout)
	CMP	BYTE [PUTCHR],0C3H
	JE	NOT.CREATE

	MOV	EDX,FILE2
	MOV	CX,0
	MOV	AX,3C00H	;create
	CALL	INT21_create	;INT	21H
	JB	ERR_MAKE
	MOV	[HDL2],AX

NOT.CREATE:
	CALL	INIT_DEFINE

	CALL	INIT_IS_12TOKEN

	CALL	INIT_FILEBUF

		JMP	PRINT_HEADER
	CMP	BYTE [FLG.S],0
	JNE	PRINT_HEADER

	MOV	EBX,WORD_EC_MAIN
	MOV	BYTE [FLG.SET_STRING_MACRO],0FFH
	CALL	SET_WORD1_MACRO_BX
	MOV	BYTE [FLG.SET_STRING_MACRO],0

	mov	eax,ref_drv
	mov	[print_arg],eax

	CALL	IS_L
	JE	PRINT_HEADER.10

	CALL	PRINT
	DB	'	ORG	100H',0DH,0AH
	DB	';#INCLUDE <CLIB.ASM>',0DH,0AH,'$'
	JMP	PRINT_HEADER

WORD_EC_MAIN:
	DB	'_EC_MAIN_',0

PRINT_HEADER.10:
	CALL	PRINT
	DB	';	ORG	0',0DH,0AH
	DB	';	PUBLIC	_main',0DH,0AH
	DB	';	PUBLIC	bottom',0DH,0AH
	DB	';#INCLUDE <%0RUNTIME.CLB>',0DH,0AH,'$'

PRINT_HEADER:

	MOV	EBX,[FLG.OPT]
	CALL	PRINT
	DB	'	DB	"optimize=%L",0',0DH,0AH,'$'

	CMP	BYTE [FLG.B],0
	JNE	MODE.B.10
	CALL	PRINT
	DB	'	DB	"non-"',0DH,0AH,'$'
MODE.B.10:
	CALL	PRINT
	DB	'	DB	"bitfield",0',0DH,0AH,'$'

	CALL	GET_NCHR

	CMP	BYTE [FLG.P],0
	JNE	MAIN_PRE

	CALL	GET_WORD
MAIN:
	PUSH	[WORD_WORK_EXP_INFO]
	POP	[WORD_WORK_EXP_INFO+2*4]
		MOV	DWORD [WORD_WORK_EXP_INFO+3*4],0

	PUSH	[WORD_WORK_EXP_INFO]
	POP	[TMP_EXP_PNT]

;	CALL	CHECK_WORD

	mov	esi,word_work
	mov	al,[esi]
	cmp	al,1ah
	je	main_e

	push	main	;ret.adrs

	mov	edi,word_typedef
	call	strcmp
	je	_typedef

	mov	edi,word_asm
	call	strcmp
	je	_asm

	MOV	EDI,WORD_OPT
	CALL	STRCMP
	JE	_OPT

	pop	eax	;not call

	;mov	edi,word_end
	;call	strcmp
	;je	_end

	;call	is_typename
	;jne	err_syntax

	call	declare

	;PUSHAD
	;CALL	DISP
	;DB	'&$'
	;POPAD

	JMP	MAIN

;main.asm:
;	call	_asm
;	jmp	main


KEEP_EXP:
	ret

	PUSH	EBX
	MOV	EBX,[WORD_WORK_EXP_INFO+2*4]
	CMP	EBX,[TMP_EXP_PNT]
	JBE	KEEP_EXP.E

	PUSH	[WORD_WORK_EXP_INFO+2*4]
	POP	[TMP_EXP_PNT]
KEEP_EXP.E:
	POP	EBX
	RET

FREE_EXP:
	RET

	PUSH	[TMP_EXP_PNT]
	POP	[WORD_WORK_EXP_INFO+2*4]
	RET



;
;
;

MAIN_PRE:
;	CALL	GET_WORD

	MOV	AX,[WORD_WORK]
	CMP	AL,1AH
	JE	MAIN_PRE.E

;		JMP	MAIN_PRE.20

MAIN_PRE.05:
	MOV	AL,[CHR_WORK]
	CMP	AL,1AH
	JE	MAIN_PRE.E

	CMP	AL,20H
	JE	MAIN_PRE.10
	CMP	AL,09H
	JE	MAIN_PRE.10
	CMP	AL,0DH
	JE	MAIN_PRE.10
	CMP	AL,0AH
	JE	MAIN_PRE.10
	JMP	MAIN_PRE.20
MAIN_PRE.10:
	MOV	DL,AL
	MOV	AH,2
	CALL	INT21_putchr	;INT	21H

	CALL	GET_NCHR
	JMP	MAIN_PRE.05
MAIN_PRE.20:
	CMP	AL,'"'
	JE	MAIN_PRE.DQ

;	PUSH	EAX
;	MOV	AL,[CHR_WORK]
;	CALL	UNGETC
;	POP	EAX
;	MOV	[CHR_WORK],AL
	CALL	GET_WORD

	MOV	ESI,WORD_WORK
	MOV	EDI,WORD_END
	;CALL	STRCMP
	;JE	MAIN_PRE.E

	MOV	ESI,WORD_WORK
MAIN_PRE.50:
	MOV	AL,[ESI]
	OR	AL,AL
	JE	MAIN_PRE.51
	INC	ESI
	PUSH	ESI
	MOV	DL,AL
	MOV	AH,2
	CALL	INT21_putchr	;INT	21H
	POP	ESI
	JMP	MAIN_PRE.50
MAIN_PRE.51:

	JMP	MAIN_PRE

MAIN_PRE.DQ:
	MOV	AH,2
	MOV	DL,AL
	CALL	INT21_putchr	;INT	21H
MAIN_PRE.DQ.10:
	CALL	GET_NCHR
MAIN_PRE.DQ.11:
	MOV	AL,[CHR_WORK]
	PUSH	EAX
	MOV	DL,AL
	MOV	AH,2
	CALL	INT21_putchr	;INT	21H
	POP	EAX
	CMP	AL,'"'
	JNE	MAIN_PRE.DQ.10
	CALL	GET_NCHR
	JMP	MAIN_PRE.05

MAIN_PRE.E:
	CALL	FCBDEC
	JB	MAIN_E
	JMP	MAIN_PRE


;
;
;

MAIN_E:



MAIN_E.10:
	CMP	BYTE [IN_FUNC],1
	JE	ERR_INFUNC

	PUSH	[FLG.V]
	PUSH	[FLG.D]
	MOV	BYTE [FLG.V],0FFH
	MOV	BYTE [FLG.D],0FFH

	mov	ebx,[LABEL_NO]
	call	PUTHEXD

	CALL	DISP_CON
	DB	0DH,0AH
	DB	'complete',0DH,0AH,'$'

	POP	[FLG.D]
	POP	[FLG.V]

	CALL	PRINT_STRING_GLOBAL

	CALL	PRINT_PUBLIC

MAIN_E.ERR:
	CALL	PUTCRLF
	;CALL	LIST_WORD
	CMP	BYTE [FLG.M],0
	JE	EXIT_CLOSE
	PUSH	[FLG.D]
	PUSH	[FLG.V]
	MOV	BYTE [FLG.V],0FFH
	MOV	BYTE [FLG.D],0FFH
	MOV	AH,1
	CALL	INT21_getchr	;INT	21H
	;CALL	LIST_WORD_GLOBAL
	POP	EAX
	MOV	[FLG.V],AL
	POP	EAX
	MOV	[FLG.D],AL

EXIT_CLOSE:
		JMP	MAIN_E.22
	CMP	BYTE [FLG.S],0
	JNE	MAIN_E.22
	CALL	PRINT
	DB	';bottom:',0DH,0AH,'$'
MAIN_E.22:
	CALL	CLOSE2

EXIT:
	MOV	AL,[EXITCODE]
	MOV	AH,4CH
	CALL	INT21_exit	;INT	21H



;
;
;

TEST:
	RET

;
;
;

BLOCK:
	PUSH	[WORD_WORK_GLOBAL_SAVE]
	PUSH	[WORD_WORK_GLOBAL_INFO+2*4]
	PUSH	[WORD_WORK_GLOBAL_INFO+3*4]
	PUSH	[FUNC_INIT_EXP_TOP]
	PUSH	[FUNC_INIT_EXP]
;	PUSH	[STRING_PNT]	need for label

	MOV	EAX,[WORD_WORK_GLOBAL_INFO+3*4]	;2*4]
	MOV	[WORD_WORK_GLOBAL_SAVE],EAX

	MOV	DWORD [FUNC_INIT_EXP_TOP],-1
	MOV	DWORD [FUNC_INIT_EXP],0

BLOCK.10:
	MOV	AX,[WORD_WORK]
	CMP	AX,'}'
	JE	BLOCK.E

		MOV	ESI,WORD_STATIC
		MOV	EDI,WORD_WORK
		CALL	STRCMP
		;JE	ERR_SYNTAX
		JE	BLOCK.STATIC

	CALL	CHECK_WORD
	JMP	BLOCK.10

BLOCK.STATIC:
	CALL	MAKE_LABEL
	PUSH	EBX
	CALL	JMP_LABEL

	CALL	CHECK_WORD
	POP	EBX
	CALL	PRINT_LABEL
	JMP	BLOCK.10

BLOCK.E:
	CALL	CHECK_STRING_LOCAL
	JE	BLOCK.E.10

	CALL	MAKE_LABEL
	PUSH	EBX
	CALL	JMP_LABEL

	CALL	PRINT_STRING_LOCAL

	POP	EBX
	CALL	PRINT_LABEL
BLOCK.E.10:
;	POP	[STRING_PNT]
	POP	[FUNC_INIT_EXP]
	POP	[FUNC_INIT_EXP_TOP]
	POP	[WORD_WORK_GLOBAL_INFO+3*4]
	POP	[WORD_WORK_GLOBAL_INFO+2*4]
	POP	[WORD_WORK_GLOBAL_SAVE]

	CALL	GET_WORD
	RET


CHECK_WORD_BLOCK:
	CALL	GET_WORD	;skip '{'
	JMP	BLOCK

;
;
;

CHECK_WORD:
	MOV	AL,'.'
	CALL	PUTCHR_CON

	CALL	PRINT
	DB	0DH,0AH,'$'

	MOV	EDI,WORD_WORK

	MOV	AX,[WORD_WORK]
	CMP	AL,1AH
	JE	MAIN_E
	CMP	AX,';'
	JE	CHECK_WORD_SEMICLN
	CMP	AX,'{'
	JE	CHECK_WORD_BLOCK

	MOV	ESI,WORD_END
	;CALL	STRCMP
	;JE	_END

	MOV	ESI,WORD_GOTO
	CALL	STRCMP
	JE	_GOTO

	MOV	ESI,WORD_IF
	CALL	STRCMP
	JE	_IF

	MOV	ESI,WORD_RETURN
	CALL	STRCMP
	JE	_RETURN

	MOV	ESI,WORD_WHILE
	CALL	STRCMP
	JE	_WHILE

	MOV	ESI,WORD_DO
	CALL	STRCMP
	JE	_DO

	MOV	ESI,WORD_FOR
	CALL	STRCMP
	JE	_FOR

	MOV	ESI,WORD_CONTINUE
	CALL	STRCMP
	JE	_CONTINUE

	MOV	ESI,WORD_BREAK
	CALL	STRCMP
	JE	_BREAK

	MOV	ESI,WORD_TYPEDEF
	CALL	STRCMP
	JE	_TYPEDEF

	MOV	ESI,WORD_SWITCH
	CALL	STRCMP
	JE	_SWITCH

		MOV	ESI,WORD_CASE
		CALL	STRCMP
		JE	_CASE2

	MOV	ESI,WORD_ASM
	CALL	STRCMP
	JE	_ASM

	MOV	ESI,WORD_OPT
	CALL	STRCMP
	JE	_OPT

	CMP	BYTE [CHR_WORK],':'
	JE	_LABEL

	CALL	IS_TYPENAME
	JE	DECLARE

	JMP	CHECK_WORD_EXP

	CALL	DISP
	DB	'CHECK_WORD$'
	JMP	ERR_SYNTAX

;
_CASE2:
	CALL	[FUNC_CASE2]
	RET

FUNC_CASE2:
	DD	FUNC_CASE2_DUMMY

FUNC_CASE2_DUMMY:
	JMP	ERR_SYNTAX



;CHECK_WORD_EOF:
;	CALL	FCBDEC
;	JB	MAIN_E
;	


CHECK_WORD_SEMICLN:
	CALL	GET_WORD	;skip ';'
	RET

;
;
;

CHECK_WORD_EXP:
	PUSH	[WORD_WORK_EXP_INFO+2*4]
	PUSH	[WORD_WORK_EXP_INFO+3*4]

	CALL	EXP
		CALL	COND_TO_ARITH

		PUSHAD
		MOV	AL,'#'
		CALL	PUTCHR_CON
		;CALL	DISP_SI_CX
		POPAD

		;PUSHAD
		;CALL	LIST_WORD_EXP
		;POPAD

	;CALL	MK_REF
		CALL	MK0_REF

	;	CALL	DISP_CON
	;	DB	'm$'

	POP	[WORD_WORK_EXP_INFO+3*4]
	POP	[WORD_WORK_EXP_INFO+2*4]

	MOV	AX,';'
	CALL	SKIP_WORD
	RET

;
;
;

WORD_LONG:DB	'long',0
WORD_SHORT:DB	'short',0
WORD_INT:DB	'int',0
WORD_CHAR:DB	'char',0
WORD_VOID:DB	'void',0
WORD_FLOAT:DB	'float',0
WORD_DOUBLE:DB	'double',0

WORD_END:DB	'end',0
WORD_GOTO:DB	'goto',0
WORD_IF:DB	'if',0
WORD_ELSE:DB	'else',0
WORD_WHILE:DB	'while',0
WORD_DO:DB	'do',0
WORD_SIZEOF:DB	'sizeof',0
WORD_FUNC:DB	'func',0
WORD_CALL:DB	'call',0
WORD_ENUM:DB	'enum',0
WORD_STRUCT:DB	'struct',0
WORD_UNION:DB	'union',0
WORD_TYPE:DB	'type',0
WORD_RETURN:DB	'return',0
WORD_FOR:DB	'for',0
WORD_CONTINUE:DB 'continue',0
WORD_BREAK:DB	'break',0
WORD_TYPEDEF:DB	'typedef',0
WORD_SWITCH:DB	'switch',0
WORD_CASE:DB	'case',0
WORD_DEFAULT:DB	'default',0

WORD_REGISTER:DB	'register',0
WORD_EXTRN:DB	'extern',0
WORD_AUTO:DB	'auto',0
WORD_STATIC:DB	'static',0
WORD_UNSIGNED:DB	'unsigned',0
WORD_SIGNED:DB	'signed',0
WORD_CONST:DB	'const',0

WORD_ASM:DB	'asm',0

WORD_OPT:
	;DB	'opt',0
	DB	'__opt__',0

WORD_CLASS:
	DB	'class',0
;
;
;

_OPT:
	CALL	GET_WORD

	MOV	ESI,WORD_WORK
_OPT.10:
	LODSB
	OR	AL,AL
	JE	_OPT.E

	CMP	AL,'o'
	JE	_OPTO
	CMP	AL,'k'
	JE	_OPTK
	CMP	AL,'a'
	JE	_OPTA
	CMP	AL,'v'
	JE	_OPTV
	JMP	ERR_SYNTAX

_OPTO:
	LODSB
	SUB	AL,'0'
	ADD	AL,0FFH
	MOV	AL,0
	SBB	AL,AL

;	MOV	AL,[FLG.OPT]
;	XOR	AL,0FFH
	MOV	[FLG.OPT],AL
	JMP	_OPT.10

_OPTK:
	LODSB
	SUB	AL,'0'
	ROR	AL,1
	SAR	AL,7
	MOV	[FLG.K],AL
	JMP	_OPT.10

_OPTA:
	LODSB
	SUB	AL,'0'
	ROR	AL,1
	SAR	AL,7
	MOV	[FLG.A],AL
	JMP	_OPT.10

_OPTV:
	LODSB
	SUB	AL,'0'
	ROR	AL,1
	SAR	AL,7
	MOV	[FLG.V],AL
	JMP	_OPT.10

_OPT.E:
	CALL	GET_WORD
	RET




;
;
;

_ASM:
	CALL	GET_WORD	;skip word

	MOV	AX,[WORD_WORK]
	CMP	AX,'{'
	JNE	ERR_SYNTAX

	CALL	PRINT_CRLF

_ASM.10:
	MOV	AL,[CHR_WORK]
	CMP	AL,'}'
	JE	_ASM.50
	CMP	AL,1AH
	JE	ERR_EOF

	CALL	PUTCHR
	CALL	GET_NCHR
	JMP	_ASM.10

_ASM.50:
	CALL	PRINT_CRLF

	CALL	GET_NCHR
	CALL	GET_WORD
	RET


;
;
;
_LABEL:
		MOV	AL,'L'+80H
		CALL	ADD_POST

	CALL	SEARCH_WORD_LABEL
	JNB	_LABEL.10

	CALL	SET_WORD1_LABEL
	PUSH	EBX
	CALL	MAKE_LABEL
	MOV	ESI,EBX
	POP	EBX
	MOV	[EBX+2*4],ESI

		MOV	EDI,EBX

	MOV	EBX,ESI
_LABEL.05:
	PUSH	EBX
	CALL	PRINT_LABEL_NOCRLF
	POP	EBX

		PUSH	EDI
		CALL	PRINT
		DB	';%n',0DH,0AH,'$'

	CALL	GET_WORD	;skip name


	MOV	AX,':'
	CALL	SKIP_WORD

		MOV	ESI,WORD_WORK
		MOV	EDI,WORD_CASE
		CALL	STRCMP
		JE	_LABEL.R

	CALL	CHECK_WORD
_LABEL.R:
	RET

_LABEL.10:
		MOV	EDI,EBX

	MOV	EBX,[EBX+2*4]
	MOV	ESI,[EBX+2*2]
	MOV	AX,[ESI]
	CMP	AX,':'
	JNE	ERR_TYPE

	JMP	_LABEL.05


;
;
;
_SWITCH:
		PUSH	[FUNC_CASE2]
		PUSH	[CASE_WORK_TOP]
		PUSH	[CASE_WORK_PNT]
		PUSH	[CASE_WORK_END]

	PUSH	[SWITCH.L1]
	PUSH	[SWITCH.L2]
	PUSH	[WORD_WORK_EXP_INFO+2*4]
	PUSH	[WORD_WORK_EXP_INFO+3*4]
	PUSH	[BREAK.PNT]

		MOV	EAX,ESP
		MOV	[CASE_WORK_TOP],EAX
		MOV	[CASE_WORK_PNT],EAX
		SUB	ESP,4*200H
		MOV	EAX,ESP
		ADD	EAX,4*10H		;for safe
		MOV	[CASE_WORK_END],EAX

	CALL	GET_WORD	;skip 'switch'
	MOV	AX,'('
	CALL	SKIP_WORD
	CALL	EXP
	CALL	MK_REF
	MOV	[SWITCH.TYPE],ECX
	MOV	AX,')'
	CALL	SKIP_WORD

	CALL	MAKE_LABEL
	MOV	[SWITCH.L1],EBX
	CALL	JMP_LABEL
	MOV	EBX,0
	MOV	[SWITCH.L2],EBX
	CALL	MAKE_LABEL
	MOV	[BREAK.PNT],EBX
;	CALL	MAKE_LABEL
;	MOV	[SWITCH.L3],EBX

	;PUSH	DWORD 0000H
	;PUSH	DWORD 0000H
		MOV	EDI,[CASE_WORK_PNT]
		SUB	EDI,8
		MOV	[CASE_WORK_PNT],EDI
		MOV	DWORD [EDI],0
		MOV	DWORD [EDI+4],0

		MOV	DWORD [FUNC_CASE2],FUNC_CASE2A

	MOV	AX,'{'
	CALL	SKIP_WORD
_SWITCH.10:
	MOV	AX,[WORD_WORK]
	CMP	AX,'}'
	JE	_SWITCH.E

	MOV	ESI,WORD_WORK
	MOV	EDI,WORD_CASE
	CALL	STRCMP
	JE	_SWITCH.C

	MOV	EDI,WORD_DEFAULT
	CALL	STRCMP
	JE	_SWITCH.D

	PUSH	[BREAK.PNT]
	PUSH	[SWITCH.L1]
	PUSH	[SWITCH.L2]
	CALL	CHECK_WORD
	POP	[SWITCH.L2]
	POP	[SWITCH.L1]
	POP	[BREAK.PNT]

	JMP	_SWITCH.10

_SWITCH.C:
	CALL	GET_WORD	;skip 'case'
	CALL	EXP
		CALL	CUT_CAST
	MOV	EBX,[ESI+2*2]
	MOV	AX,[EBX]
	CMP	AX,'00'
	JNE	ERR_TYPE


		MOV	EDI,[CASE_WORK_PNT]
		SUB	EDI,8
		CMP	EDI,[CASE_WORK_END]
		MOV	[CASE_WORK_PNT],EDI
		JB	ERR_MEM_CASE

	;PUSH	ESI		;node
		MOV	[EDI],ESI
	CALL	MAKE_LABEL
		MOV	EDI,[CASE_WORK_PNT]
	;PUSH	EBX		;label
		MOV	[EDI+4],EBX
	CALL	PRINT_LABEL

	MOV	AX,':'
	CALL	SKIP_WORD

	JMP	_SWITCH.10

_SWITCH.D:
	CALL	GET_WORD	;skip 'default'
	CALL	MAKE_LABEL
	MOV	[SWITCH.L2],EBX
	CALL	PRINT_LABEL
	MOV	AX,':'
	CALL	SKIP_WORD
	JMP	_SWITCH.10

_SWITCH.E:
	CALL	GET_WORD	;skip '}'

	MOV	EBX,[BREAK.PNT]
	CALL	JMP_LABEL

	MOV	EBX,[SWITCH.L1]
	CALL	PRINT_LABEL
_SWITCH.E.10:
		MOV	EDI,[CASE_WORK_PNT]
		MOV	ECX,[EDI]
		MOV	EBX,[EDI+4]
		ADD	DWORD [CASE_WORK_PNT],8
	;POP	EBX		;label
	;POP	ECX		;node
	OR	EBX,EBX
	JE	_SWITCH.E.50

	MOV	EAX,[SWITCH.TYPE]
	CMP	EAX,0001H
	JE	_SWITCH.E.CHAR
	CMP	EAX,0081H
	JE	_SWITCH.E.CHAR
	CMP	EAX,0002H
	JE	_SWITCH.E.INT
	CMP	EAX,0082H
	JE	_SWITCH.E.INT
	CMP	EAX,0004H
	JE	_SWITCH.E.LONG
	CMP	EAX,0084H
	JE	_SWITCH.E.LONG
	CALL	IS_L
	JE	_SWITCH.E.LONG


_SWITCH.E.INT:
	PUSH	EBX
	PUSH	ECX
	CALL	PRINT
	DB	'	CMP	BX,%d',0DH,0AH
	DB	'	JE	_%m',0DH,0AH,'$'
	JMP	_SWITCH.E.10

_SWITCH.E.LONG:
	PUSH	EBX
;	MOVZX	EBX,CX
	MOV	EBX,[ECX+2*8]
	CALL	PRINT
	DB	'	CMP	EBX,%L',0DH,0AH
	DB	'	JE	_%m',0DH,0AH,'$'
	JMP	_SWITCH.E.10

_SWITCH.E.CHAR:
	PUSH	EBX
	PUSH	ECX
	CALL	PRINT
	DB	'	CMP	BL,%d',0DH,0AH
	DB	'	JE	_%m',0DH,0AH,'$'
	JMP	_SWITCH.E.10

_SWITCH.E.50:
	MOV	EBX,[SWITCH.L2]
	OR	EBX,EBX
	JE	_SWITCH.E.60
	CALL	JMP_LABEL
_SWITCH.E.60:
	MOV	EBX,[BREAK.PNT]
	CALL	PRINT_LABEL

		;MOV	ESP,EBP
		ADD	ESP,4*200H

	POP	[BREAK.PNT]
	POP	[WORD_WORK_EXP_INFO+3*4]
	POP	[WORD_WORK_EXP_INFO+2*4]
	POP	[SWITCH.L2]
	POP	[SWITCH.L1]

		POP	[CASE_WORK_END]
		POP	[CASE_WORK_PNT]
		POP	[CASE_WORK_TOP]
		POP	[FUNC_CASE2]
	RET

;
FUNC_CASE2A:
	CALL	GET_WORD	;skip 'case'
	CALL	EXP
		CALL	CUT_CAST
	MOV	EBX,[ESI+2*2]
	MOV	AX,[EBX]
	CMP	AX,'00'
	JNE	ERR_TYPE

		MOV	EDI,[CASE_WORK_PNT]
		SUB	EDI,8
		CMP	EDI,[CASE_WORK_END]
		MOV	[CASE_WORK_PNT],EDI
		JB	ERR_MEM_CASE

	;PUSH	ESI		;node
		MOV	[EDI],ESI
	CALL	MAKE_LABEL
		MOV	EDI,[CASE_WORK_PNT]
	;PUSH	EBX		;label
		MOV	[EDI+4],EBX
	CALL	PRINT_LABEL

	MOV	AX,':'
	CALL	SKIP_WORD

	;JMP	_SWITCH.10
	RET




;
;
;
_TYPEDEF:
	CALL	GET_WORD	;skip 'typedef'

	CALL	TYPENAME
_TYPEDEF.10:
	PUSH	EBX		;type

	PUSH	EBX
	CALL	DEF
	POP	EBX
	MOV	[ESI+2*4],EBX

	PUSH	ESI
	MOV	AX,'ty'+8080H
	CALL	MAKE_WORD1
	MOV	EDI,EBX
	POP	ESI

	MOV	EBX,[NAME_PNT]
		OR	DWORD [EBX+2*18],2
	PUSH	[EBX+2*4]
	MOV	[EBX+2*4],EDI
	POP	EBX

	MOV	[EDI+2*4],EBX

	MOV	AX,[WORD_WORK]
	CMP	AX,';'
	JE	_TYPEDEF.E

	MOV	AX,','
	CALL	SKIP_WORD

	POP	EBX
	JMP	_TYPEDEF.10

_TYPEDEF.E:
	POP	EBX		;discard type

	MOV	AX,';'
	CALL	SKIP_WORD
	RET

;
;
;
_CONTINUE:
	CALL	GET_WORD	;skip 'continue'

	MOV	EBX,[CONTINUE.PNT]
	CALL	JMP_LABEL

	MOV	AX,';'
	CALL	SKIP_WORD
	RET



;
;
;
_BREAK:
	CALL	GET_WORD	;skip 'break'

	MOV	EBX,[BREAK.PNT]
	CALL	JMP_LABEL

	MOV	AX,';'
	CALL	SKIP_WORD
	RET



;		(exp1)
;	L1:	if !(exp2) got L2
;		..
;cont	L3:	(exp3)
;		goto L1
;
;break	L2:
;

_FOR:
	PUSH	[WORD_WORK_EXP_INFO+2*4]
	PUSH	[WORD_WORK_EXP_INFO+3*4]

	PUSH	[CONTINUE.PNT]
	PUSH	[BREAK.PNT]

	PUSH	EBP
	MOV	EBP,ESP
	SUB	ESP,4*8

	CALL	GET_WORD	;skip 'for'
	MOV	AX,'('
	CALL	SKIP_WORD

	MOV	AX,[WORD_WORK]
	CMP	AX,';'
	JE	_FOR2

	CALL	EXP			;1st
	CALL	MK
_FOR2:
	CALL	MAKE_LABEL
	MOV	[EBP+W1],EBX

	CALL	PRINT_LABEL

	MOV	AX,';'
	CALL	SKIP_WORD

	CALL	MAKE_LABEL
	MOV	[BREAK.PNT],EBX
	MOV	[EBP+W2],EBX

	MOV	AX,[WORD_WORK]
	CMP	AX,';'
	JE	_FOR3

	PUSH	EBX
	CALL	EXP			;2nd
	CALL	ARITH_TO_COND
	POP	EBX
	MOV	EDX,0
	CALL	_IF.MAKE
_FOR3:
	MOV	AX,';'
	CALL	SKIP_WORD

	MOV	DWORD [EBP+W3],0
	MOV	AX,[WORD_WORK]
	CMP	AX,')'
	JE	_FOR4

	MOV	DWORD [EBP+W3],1
	CALL	EXP			;3rd
_FOR4:
	CALL	KEEP_EXP

	PUSH	ESI		;3rd
	PUSH	ECX
	MOV	AX,')'
	CALL	SKIP_WORD

	PUSH	[CONTINUE.PNT]
	PUSH	[BREAK.PNT]
	CALL	MAKE_LABEL
	MOV	[CONTINUE.PNT],EBX
	MOV	[EBP+W4],EBX

	CALL	CHECK_WORD
	POP	[BREAK.PNT]
	POP	[CONTINUE.PNT]

	MOV	EBX,[EBP+W4]
	CALL	PRINT_LABEL

	POP	ECX		;3rd
	POP	ESI
	CMP	DWORD [EBP+W3],0
	JE	_FOR4.10
	;CALL	MK
	CALL	MK0
	CALL	PRINT_CRLF
_FOR4.10:

	MOV	EBX,[EBP+W1]
	CALL	JMP_LABEL

	MOV	EBX,[EBP+W2]
	CALL	PRINT_LABEL

	MOV	ESP,EBP
	POP	EBP

	POP	[BREAK.PNT]
	POP	[CONTINUE.PNT]

	POP	[WORD_WORK_EXP_INFO+3*4]
	POP	[WORD_WORK_EXP_INFO+2*4]
	RET

;
;	L1:
;
;		
;

_DO:
	PUSH	[CONTINUE.PNT]
	PUSH	[BREAK.PNT]

	PUSH	EBP
	MOV	EBP,ESP
	SUB	ESP,4*4

	CALL	GET_WORD	;skip 'do'

	CALL	MAKE_LABEL
	MOV	[BREAK.PNT],EBX
	MOV	[EBP+W1],EBX

	CALL	MAKE_LABEL
	MOV	[CONTINUE.PNT],EBX
	MOV	[EBP+W3],EBX

	CALL	MAKE_LABEL
	MOV	[EBP+W2],EBX

	PUSH	EBX
	CALL	PRINT
	DB	'_%m:',0DH,0AH,'$'

	PUSH	[CONTINUE.PNT]
	PUSH	[BREAK.PNT]
	CALL	CHECK_WORD
	POP	[BREAK.PNT]
	POP	[CONTINUE.PNT]

	MOV	ESI,WORD_WORK
	MOV	EDI,WORD_WHILE
	CALL	STRCMP
	JNE	ERR_SYNTAX

	CALL	GET_WORD	;skip 'while'

	MOV	AX,'('
	CALL	SKIP_WORD
	CALL	EXP
	CALL	ARITH_TO_COND
	MOV	AX,')'
	CALL	SKIP_WORD
	MOV	AX,';'
	CALL	SKIP_WORD

	MOV	EBX,[EBP+W3]	;continue
	CALL	PRINT_LABEL

	MOV	EBX,[EBP+W2]

	MOV	EDX,-1
	CALL	_IF.MAKE

	MOV	EBX,[EBP+W1]	;break
	CALL	PRINT_LABEL

	ADD	ESP,4*4
	POP	EBP

	POP	[BREAK.PNT]
	POP	[CONTINUE.PNT]
	RET

;
;
;
_WHILE:
	PUSH	[CONTINUE.PNT]
	PUSH	[BREAK.PNT]
	PUSH	[WORD_WORK_EXP_INFO+2*4]
	PUSH	[WORD_WORK_EXP_INFO+3*4]

	PUSH	EBP
	MOV	EBP,ESP
	SUB	ESP,2*10H

	CALL	GET_WORD	;skip 'while'
	MOV	AX,'('
	CALL	SKIP_WORD

	CALL	MAKE_LABEL
	MOV	[EBP+W1],EBX
	MOV	[CONTINUE.PNT],EBX
	CALL	PRINT_LABEL

	CALL	EXP
	CALL	ARITH_TO_COND
	MOV	AX,')'
	CALL	SKIP_WORD

	CALL	MAKE_LABEL
	MOV	[EBP+W2],EBX
	MOV	[BREAK.PNT],EBX
	MOV	EDX,0
	CALL	_IF.MAKE

	PUSH	[CONTINUE.PNT]
	PUSH	[BREAK.PNT]
	CALL	CHECK_WORD
	POP	[BREAK.PNT]
	POP	[CONTINUE.PNT]

	MOV	EBX,[EBP+W1]
	CALL	JMP_LABEL

	MOV	EBX,[EBP+W2]
	CALL	PRINT_LABEL

	MOV	ESP,EBP
	POP	EBP

	POP	[WORD_WORK_EXP_INFO+3*4]
	POP	[WORD_WORK_EXP_INFO+2*4]
	POP	[BREAK.PNT]
	POP	[CONTINUE.PNT]
	RET

;
;
;
_RETURN:
	CALL	GET_WORD	;skip 'return'
	MOV	AX,[WORD_WORK]
	CMP	AX,';'
	JE	_RETURN.10

		MOV	EAX,[FUNC_TYPE]
		OR	EAX,EAX
		JE	ERR_TYPE

	CALL	EXP
	CALL	COND_TO_ARITH

	;	CMP	ECX,100H
	;	JB	_RETURN.20
	;	MOV	EAX,[ECX+2*2]
	;	MOV	AX,[EAX]
	;	CMP	AX,'{'
	;	JE	_RETURN.21
_RETURN.20:
		MOV	ECX,[FUNC_TYPE]
		CALL	EXP_CAST2
_RETURN.21:
		CMP	ECX,100H
		JB	_RETURN.CHK.E
		MOV	EAX,[ECX+2*2]
		MOV	AX,[EAX]
		CMP	AX,'{'
		JNE	_RETURN.CHK.E

		CALL	MK_REF

		MOV	EBX,[FUNC_NEXT_ARG]
		CALL	PRINT
		DB	'	LEA	EDI,[EBP+%L]',0DH,0AH,'$'

		MOV	ESI,ECX
		CALL	SIZEOF

		MOV	EBX,EDX
		CALL	PRINT
		DB	'	MOV	ECX,%L',0DH,0AH
		DB	'	CALL	retstruct',0DH,0AH,'$'
		JMP	_RETURN.10

_RETURN.CHK.E:

	CALL	MK_REF

;	MOV	EDX,ECX
;	MOV	ECX,[FUNC_TYPE]
;	CALL	CAST_CX_DX

_RETURN.10:
	PUSH	[FUNC_PNT]
	CALL	PRINT
	DB	'	jmp	%n_ret',0DH,0AH,'$'

	MOV	AX,';'
	CALL	SKIP_WORD
	RET


;
;		if !(exp) goto L1
;		..
;		goto L2
;	L1:
;		..
;	L2:

_IF:
	PUSH	[WORD_WORK_EXP_INFO+2*4]
	PUSH	[WORD_WORK_EXP_INFO+3*4]

	PUSH	EBP
	MOV	EBP,ESP
	SUB	ESP,4*8

	CALL	GET_WORD	;skip 'if'
	MOV	AX,'('
	CALL	SKIP_WORD
	CALL	EXP
	CALL	ARITH_TO_COND
	MOV	AX,')'
	CALL	SKIP_WORD

	CALL	DISP_SI_CX

	CALL	MAKE_LABEL
	MOV	[EBP+W1],EBX
	CALL	MAKE_LABEL
	MOV	[EBP+W2],EBX

	MOV	EBX,[EBP+W1]
	MOV	EDX,0		;false
	CALL	_IF.MAKE

	CALL	CHECK_WORD

		CALL	PRINT
		DB	0DH,0AH,'$'

	MOV	EBX,[EBP+W2]
	;	CMP	EBX,[EBP+W1]
	;	JE	_IF.NOTJMP

	CALL	JMP_LABEL

_IF.NOTJMP:
	MOV	EBX,[EBP+W1]
	CALL	PRINT_LABEL

	MOV	EDI,WORD_WORK
	MOV	ESI,WORD_ELSE
	CALL	STRCMP
	JNE	_IF.80

	CALL	GET_WORD	;skip 'else'

	CALL	CHECK_WORD

_IF.80:
	MOV	EBX,[EBP+W2]
	CALL	PRINT_LABEL

	ADD	ESP,4*8
	POP	EBP

	POP	[WORD_WORK_EXP_INFO+3*4]
	POP	[WORD_WORK_EXP_INFO+2*4]
	RET

;
;	ESI:node
;	EBX:label
;	EDX:true/false
;

_IF.MAKE:
	PUSH	EBX
	MOV	EBX,[ESI+2*2]
	MOV	AX,[EBX]
	POP	EBX

	CMP	AX,'!'
	JE	_IF.NOT
	CMP	AX,'&&'
	JE	_IF.AND2
	CMP	AX,'||'
	JE	_IF.OR2

	CMP	AX,'=='
;	MOV	EDI,IF_NTEQ
	MOV	EDI,0
	JE	_IF.10

	CMP	AX,'=!'
;	MOV	EDI,IF_EQ
	MOV	EDI,1
	JE	_IF.10

	CMP	AX,'>'
;	MOV	EDI,IF_LTEQ
	MOV	EDI,2
	JE	_IF.10

	CMP	AX,'<'
;	MOV	EDI,IF_GTEQ
	MOV	EDI,4
	JE	_IF.10

	CMP	AX,'=>'
;	MOV	EDI,IF_LT
	MOV	EDI,5
	JE	_IF.10
	CMP	AX,'>='
	JE	_IF.10

	CMP	AX,'<='
;	MOV	EDI,IF_GT
	MOV	EDI,3
	JE	_IF.10
	CMP	AX,'=<'
	JE	_IF.10

	PUSH	EAX
	CALL	PUTCHR_CON
	POP	EAX
	MOV	AL,AH
	CALL	PUTCHR_CON

	CALL	DISP_CON
	DB	'if$'

	MOV	BYTE [FLG.D],0FFH
	MOV	BYTE [FLG.V],0FFH
	;CALL	LIST_WORD_EXP
	;CALL	LIST_WORD_GLOBAL
	JMP	ERR_SYNTAX

;

_IF.NOT:
	MOV	ESI,[ESI+2*4]
	NOT	EDX

	JMP	_IF.MAKE

;
;	EBX:label
;	EDX:true/false
;

_IF.AND2:
	OR	EDX,EDX
	JE	_IF.AND2.F

	MOV	EDX,EBX

	CALL	MAKE_LABEL
	PUSH	EBX

	PUSH	EDX
	PUSH	ESI
	MOV	ESI,[ESI+2*4]
	MOV	EDX,0
	CALL	_IF.MAKE
	POP	ESI
	POP	EBX
	MOV	ESI,[ESI+2*6]
	MOV	EDX,-1
	CALL	_IF.MAKE

	POP	EBX
	CALL	PRINT_LABEL
	RET

_IF.AND2.F:
	PUSH	EBX
	PUSH	ESI
	MOV	ESI,[ESI+2*4]
	MOV	EDX,0
	CALL	_IF.MAKE
	POP	ESI
	POP	EBX
	MOV	ESI,[ESI+2*6]
	MOV	EDX,0
	CALL	_IF.MAKE
	RET

;
;
;

_IF.OR2:
	OR	EDX,EDX
	JE	_IF.OR2.F

	PUSH	EBX
	PUSH	ESI
	MOV	ESI,[ESI+2*4]
	MOV	EDX,-1
	CALL	_IF.MAKE
	POP	ESI
	POP	EBX
	MOV	ESI,[ESI+2*6]
	MOV	EDX,-1
	CALL	_IF.MAKE
	RET

_IF.OR2.F:
	MOV	EDX,EBX

	CALL	MAKE_LABEL
	PUSH	EBX

	PUSH	EDX
	PUSH	ESI
	MOV	ESI,[ESI+2*4]
	MOV	EDX,-1
	CALL	_IF.MAKE
	POP	ESI
	POP	EBX
	MOV	ESI,[ESI+2*6]
	MOV	EDX,0
	CALL	_IF.MAKE
	POP	EBX
	CALL	PRINT_LABEL
	RET

;
;
;

_IF.10:
;W1	left type
;W2	right type
;W3	true/false (0/1)
;W4	prog (=,!=,>,<,>=,<=)
;W5	label
;W6	if.type

	PUSH	EBP
	MOV	EBP,ESP
	SUB	ESP,4*8

	MOV	[EBP+W3],EDX	;true/false
	MOV	[EBP+W4],EDI	;prog

	MOV	[EBP+W5],EBX	;label

	;CALL	IS_OPT
	CALL	IS_OPT2
	JE	_IF.OPT
_IF.NOPT:
	CALL	MK_REF_L
	MOV	[EBP+W1],ECX
	MOV	EAX,ECX
	CALL	PUSH_BX

	CALL	MK_REF_R
	MOV	[EBP+W2],ECX
	MOV	EAX,[EBP+W1]
	CALL	POP_AX

	MOV	EAX,[EBP+W1]
	AND	EAX,[EBP+W2]
	AND	EAX,80H
	MOV	[EBP+W6],EAX	;if.type

	MOV	ECX,[EBP+W1]
		CMP	ECX,00C4H
		JE	_IF.F
	CMP	ECX,100H
	JNB	_IF.PNT
	MOV	ECX,[EBP+W2]
	CMP	ECX,100H
	JNB	_IF.PNT

	MOV	EAX,[EBP+W1]
	OR	EAX,[EBP+W2]
	AND	EAX,0FH;7FH
	CMP	EAX,0002H
	JBE	_IF.WORD

_IF.LONG:
	CALL	PRINT
	DB	'	CMP	EAX,EBX',0DH,0AH,'$'
	JMP	_IF.31

;

_IF.WORD:
	CALL	PRINT
	DB	'	CMP	AX,BX',0DH,0AH,'$'
	JMP	_IF.31

;
_IF.F:
	CALL	PRINT
	DB	'	call	fcomp_',0DH,0AH,'$'
	JMP	_IF.31


;

_IF.PNT:
	;	PUSHAD
	;	CALL	PRINT
	;	DB	';ptr',0DH,0AH,'$'
	;	POPAD

	MOV	DWORD [EBP+W6],0;80H	;0	;80H ####

	CALL	IS_L
	JE	_IF.LONG
	JMP	_IF.WORD

_IF.31:

_IF.OPT.R:

	MOV	AH,[EBP+W6]	;AH=is_signed
	AND	AH,80H

	MOV	AL,[EBP+W4]	;cond
	CMP	BYTE [EBP+W3],0
	JE	_IF.OPT.R.10
	XOR	AL,1

_IF.OPT.R.10:
	XOR	AL,1
	MOV	EBX,[EBP+W5]	;label
	CALL	IF_SUB

	MOV	EBX,[EBP+W5]	;need ?

	ADD	ESP,4*8
	POP	EBP
	RET

;
IS_NUM_L:
	MOV	EAX,[ESI+2*4]
	CMP	EAX,100H
	JB	SHORT IS_NUM_L.R
	MOV	EAX,[EAX+2*2]
	MOV	AX,[EAX]
	CMP	AX,'00'
IS_NUM_L.R:
	RET

;

IS_NUM_R:
	MOV	EAX,[ESI+2*6]
	CMP	EAX,100H
	JB	SHORT IS_NUM_R.R
	MOV	EAX,[EAX+2*2]
	MOV	AX,[EAX]
	CMP	AX,'00'
IS_NUM_R.R:
	RET
;
IS_NAME_L:
	MOV	EAX,[ESI+2*4]
	JMP	IS_NAME_R.10

;
IS_NAME_R:
	MOV	EAX,[ESI+2*6]

IS_NAME_R.10:
	CMP	EAX,100H
	JB	SHORT IS_NAME_R.R
	MOV	EAX,[EAX+2*2]
	MOV	AX,[EAX]
	CALL	IS_CCHR_F
IS_NAME_R.R:
	RET

;
GET_NUM_L:
	MOV	EAX,[ESI+2*4]
	MOV	EAX,[EAX+2*8]
	MOV	EBX,EAX
	RET

;
GET_NUM_R:
	MOV	EAX,[ESI+2*6]
	MOV	EAX,[EAX+2*8]
	MOV	EBX,EAX
	RET

;
;	optimize
;		if(? cmp #)
;	FUTURE
;		if(? cmp name)
;

_IF.OPT:
	CALL	IS_NUM_R
	JNE	_IF.NOPT

;	? cmp #

	MOV	EBX,[ESI+2*6]
	MOV	ECX,[EBX+2*4]
	MOV	[EBP+W2],ECX	;r type
		CMP	ECX,00C4H
		JE	_IF.NOPT

	CALL	MK_REF_L
	MOV	[EBP+W1],ECX	;l type

	CALL	_SET_IF_TYPE

	CALL	GET_NUM_R

	CMP	ECX,0004H
	JE	_IF.OPT.L
	CMP	ECX,0084H
	JE	_IF.OPT.L

_IF.OPT.L:
	OR	EBX,EBX
	JE	_IF.OPT.L#0
	CALL	PRINT
	DB	'	CMP	!BX,%L',0DH,0AH,'$'
	JMP	_IF.OPT.50

_IF.OPT.L#0:
	CALL	PRINT
	DB	'	OR	!BX,!BX',0DH,0AH,'$'
	JMP	_IF.OPT.50

_IF.OPT.50:
	MOV	ECX,[EBP+W1]
	MOV	[IF.TYPE],ECX
	JMP	_IF.OPT.R

;
;	set [+W6] from [+W1],[+W2]
;

_SET_IF_TYPE:
	MOV	EAX,[EBP+W1]
	AND	EAX,[EBP+W2]
	AND	EAX,80H
	MOV	[EBP+W6],EAX	;if.type

	MOV	ECX,[EBP+W1]
	CMP	ECX,100H
	JNB	_SET_IF_TYPE.PNT
	MOV	ECX,[EBP+W2]
	CMP	ECX,100H
	JNB	_SET_IF_TYPE.PNT

;	MOV	EAX,[EBP+W1]
;	OR	EAX,[EBP+W2]
;	AND	EAX,7FH
;	CMP	EAX,0002H
;	JBE	_IF.WORD

	RET

_SET_IF_TYPE.PNT:
	MOV	DWORD [EBP+W6],0	;80H
	RET

;



;
;
;

IF_SUB:
	CMP	AH,0
	JE	IF_SUBU

	CMP	AL,0
	JE	IF_EQ
	CMP	AL,1
	JE	IF_NTEQ
	CMP	AL,2
	JE	IF_GT
	CMP	AL,3
	JE	IF_LTEQ
	CMP	AL,4
	JE	IF_LT
	CMP	AL,5
	JE	IF_GTEQ
	JMP	IF_SUB.ERR

IF_SUBU:
	CMP	AL,0
	JE	IF_EQ
	CMP	AL,1
	JE	IF_NTEQ
	CMP	AL,2
	JE	IF_UGT
	CMP	AL,3
	JE	IF_ULTEQ
	CMP	AL,4
	JE	IF_ULT
	CMP	AL,5
	JE	IF_UGTEQ

IF_SUB.ERR:
	CALL	DISP_CON
	DB	'if_sub error$'
	JMP	ERR_SYNTAX



;
;
;

IF_NTEQ:
	PUSH	EBX
	CALL	PRINT
	DB	'	JNE	_%m',0DH,0AH,'$'
	RET

IF_EQ:
	PUSH	EBX
	CALL	PRINT
	DB	'	JE	_%m',0DH,0AH,'$'
	RET

IF_GT:
	PUSH	EBX
	CALL	PRINT
	DB	'	JG	_%m',0DH,0AH,'$'
	RET

IF_UGT:
	PUSH	EBX
	CALL	PRINT
	DB	'	JA	_%m',0DH,0AH,'$'
	RET

IF_GTEQ:
	PUSH	EBX
	CALL	PRINT
	DB	'	JGE	_%m',0DH,0AH,'$'
	RET
IF_UGTEQ:
	PUSH	EBX
	CALL	PRINT
	DB	'	JAE	_%m',0DH,0AH,'$'
	RET

IF_LT:
	PUSH	EBX
	CALL	PRINT
	DB	'	JL	_%m',0DH,0AH,'$'
	RET
IF_ULT:
	PUSH	EBX
	CALL	PRINT
	DB	'	JB	_%m',0DH,0AH,'$'
	RET

IF_LTEQ:
	PUSH	EBX
	CALL	PRINT
	DB	'	JLE	_%m',0DH,0AH,'$'
	RET

IF_ULTEQ:
	PUSH	EBX
	CALL	PRINT
	DB	'	JBE	_%m',0DH,0AH,'$'
	RET

;	BX:L2

;_ELSE:
	CALL	GET_WORD	;skip 'else'

	PUSH	EBX

	CALL	MAKE_LABEL
	PUSH	EBX
	CALL	JMP_LABEL

	POP	EAX
	POP	EBX
	PUSH	EAX

	CALL	PRINT_LABEL

	PUSH	[IF.L1]
	PUSH	[IF.L2]
	CALL	CHECK_WORD
	POP	[IF.L2]
	POP	[IF.L1]

	POP	EBX
	CALL	PRINT_LABEL
	RET

;_ELSEIF:
	PUSH	EBX

	PUSH	[IF.L1]
	PUSH	[IF.L2]
	CALL	CHECK_WORD
	POP	[IF.L2]
	POP	[IF.L1]

	POP	EBX
	RET


;
;
;

_GOTO:	CALL	GET_WORD	;skip 'goto'

		MOV	AL,'L'+80H
		CALL	ADD_POST

	CALL	SEARCH_WORD_LABEL
	JB	_GOTO.U

		MOV	EDI,EBX

	MOV	EBX,[EBX+2*4]
	MOV	ESI,[EBX+2*2]
	MOV	AX,[ESI]
	CMP	AX,':'
	;JNE	ERR_TYPE
	JE	_GOTO.50
	CMP	AX,':'+80H
	JE	_GOTO.U
_GOTO.50:
	CALL	JMP_LABEL_NOCRLF

		PUSH	EDI
		CALL	PRINT
		DB	';%n',0DH,0AH,'$'

	CALL	GET_WORD
	MOV	AX,';'
	CALL	SKIP_WORD
	RET

_GOTO.U:
	CALL	SET_WORD1_LABEL
	PUSH	EBX
	CALL	MAKE_LABEL
	MOV	ESI,EBX
	POP	EBX
	MOV	[EBX+2*4],ESI

		MOV	EDI,EBX

	MOV	EBX,ESI
	JMP	_GOTO.50

;
;	ESI:string
;

PUT_STRING:
	JMP	PUT_STRING.20
PUT_STRING.10:
	CALL	PRINT
	DB	',$'
PUT_STRING.20:
	MOV	BL,[ESI]
	MOV	BH,0
	INC	ESI
	PUSH	EBX
	CALL	PRINT
	DB	'%D','$'
	POP	EBX
	OR	BL,BL
	JE	PUT_STRING.50
	JMP	PUT_STRING.10

PUT_STRING.50:
	CALL	PRINT
	DB	0DH,0AH,'$'
	RET




	DB	':_FUNC'


;
;
;
_FUNC:
	MOV	BYTE [IN_FUNC],1

	PUSH	[WORD_WORK_GLOBAL_INFO+2*4]
	PUSH	[WORD_WORK_GLOBAL_INFO+3*4]

	MOV	EAX,[WORD_WORK_GLOBAL_INFO+3*4]	;2*4]
	MOV	[WORD_WORK_GLOBAL_SAVE],EAX

	mov	dword [func_init_exp],0
	mov	dword [func_init_exp_top],0

	;push	[word_work_label_info]
	;pop	[word_work_label_info+2*4]

	MOV	EAX,[DEF_FNC_NAME]
	MOV	[FUNC_PNT],EAX
	MOV	EAX,0	;-2
	MOV	[LOCAL_LEVEL],EAX
;	MOV	AX,4	;2
;	MOV	[ARG_LEVEL],AX

		MOV	EAX,[NEXT_ARG]
		MOV	[FUNC_NEXT_ARG],EAX

			MOV	EBX,[FUNC_PNT]
			MOV	EAX,1
			OR	[EBX+2*18],EAX	;defined

		CALL	MARK_ARG	;%%%EC13

	MOV	EBX,[FUNC_PNT]
	MOV	EBX,[EBX+2*4]
	CMP	EBX,100H
	JB	ERR_TYPE

	MOV	EBX,[EBX+2*2]
	MOV	AX,[EBX]
	CMP	AX,'('
	JNE	ERR_TYPE

		MOV	EBX,[FUNC_PNT]
		MOV	EBX,[EBX+2*4]	;node '('
		MOV	EBX,[EBX+2*4]	;type
		MOV	[FUNC_TYPE],EBX

	MOV	EBX,[FUNC_PNT]
	MOV	EBX,[EBX+2*2]
	CALL	DISP_STRZ_CON
	MOV	AL,'/'
	CALL	PUTCHR_CON

	CALL	GET_WORD	;skip'{'

_FUNC.DECLARE:
	MOV	AX,[WORD_WORK]
	CMP	AX,'}'
	JE	_FUNC.PROG

		MOV	ESI,WORD_WORK
		MOV	EDI,WORD_TYPEDEF
		CALL	STRCMP
		JE	_FUNC.DECLARE.10

	CALL	IS_TYPENAME
	JNE	_FUNC.PROG
_FUNC.DECLARE.10:
	CALL	CHECK_WORD

	JMP	_FUNC.DECLARE

_FUNC.PROG:

		push	[FUNC_PNT]
		call	PRINT
		;db	'	db	',"'",'%n',"'",',0',0DH,0AH,'$'
		db	'	db	',"'",'%s',"'",',0',0DH,0AH,'$'

		CALL	PRINT_ALIGN4

	PUSH	[FUNC_PNT]	;[NAME_PNT]
	CALL	PRINT
	DB	'%n:',0DH,0AH,'$'

	PUSH	[FUNC_PNT]	;[NAME_PNT]
	CALL	PRINT
	DB	'	PUSH	!BP',0DH,0AH
	DB	'	MOV	!BP,!SP',0DH,0AH
	DB	'	SUB	!SP,%n@size',0DH,0AH,'$'

	CALL	LOAD_REGISTER

	PUSH	[STRING_PNT]
	PUSH	[FUNC_PNT]

	mov	esi,[func_init_exp_top]
_func.init.10:
	or	esi,esi
	je	_func.init.e

	push	esi
	mov	esi,[esi+2*4]
	call	mk
	pop	esi
	mov	esi,[esi+2*6]
	jmp	_func.init.10

_func.init.e:

	;CALL	BLOCK
_FUNC.PROG.10:
	MOV	AX,[WORD_WORK]
	CMP	AX,'}'
	JE	_FUNC.PROG.E
	CALL	IS_TYPENAME
	JE	ERR_SYNTAX
	CALL	CHECK_WORD
	JMP	_FUNC.PROG.10

_FUNC.PROG.E:
	CALL	GET_WORD	;skip '}'

	POP	[FUNC_PNT]	;#

	PUSH	[FUNC_PNT]
	CALL	PRINT
	DB	'%n_ret:',0DH,0AH,'$'

	CALL	PRINT
	DB	'	MOV	!SP,!BP',0DH,0AH
	DB	'	POP	!BP',0DH,0AH
	DB	'	RET',0DH,0AH,'$'

	MOV	EBX,[LOCAL_LEVEL]
	NEG	EBX
	PUSH	[FUNC_PNT]
	CALL	PRINT
	DB	'%n@size	EQU	%D',0DH,0AH,'$'

	;	CALL	LIST_WORD_GLOBAL	;debug

	CALL	PRINT_STRING_LOCAL

	CALL	CLEAR_FUNC

	CALL	DEL_LABEL

	MOV	DWORD [REGISTER_EDI],0
	MOV	DWORD [LOADED_REGISTER_EDI],0

	MOV	DWORD [FUNC_PNT],0

	POP	[STRING_PNT]

	POP	[WORD_WORK_GLOBAL_INFO+3*4]
	POP	[WORD_WORK_GLOBAL_INFO+2*4]

	MOV	BYTE [IN_FUNC],0
	RET



;
;
;
MARK_ARG:
	MOV	ESI,[FUNC_PNT]
	MOV	EBX,ESI
	MOV	ESI,[ESI+2*4]
MARK_ARG.10:
	MOV	ESI,[ESI+2*6]
	OR	ESI,ESI
	JE	MARK_ARG.R

	MOV	[ESI+2*16],EBX
	JMP	MARK_ARG.10

MARK_ARG.R:
	RET

;
;
;

CLEAR_FUNC:
	MOV	ESI,[FUNC_PNT]
CLEAR_FUNC2:
	MOV	ESI,[ESI+2*4]	;node '('

CLEAR_FUNC.10:
	MOV	ESI,[ESI+2*6]
	OR	ESI,ESI
	JE	CLEAR_FUNC.R

	PUSH	ESI

;	MOV	EBX,[ESI+2*2]
;	MOV	AX,[EBX]
;	CMP	AX,'*'
;	JNE	CLEAR_FUNC.20
;
;	CALL	CLEAR_FUNC.PNT

CLEAR_FUNC.20:
	MOV	DWORD [ESI+2*2],DUMMY_STR
	JMP	CLEAR_FUNC.10L

CLEAR_FUNC.10L:
	POP	ESI
	JMP	CLEAR_FUNC.10

CLEAR_FUNC.R:
	RET

;
CLEAR_FUNC.PNT:
	MOV	ESI,[ESI+2*4]

	MOV	EBX,[ESI+2*2]
	MOV	AX,[EBX]
	CMP	AX,'*'
	JE	CLEAR_FUNC.PNT

	RET



;
;
;

_END:	CALL	FCBDEC
	JB	MAIN_E
	CALL	GET_NCHR
	CALL	GET_WORD
	RET

	JMP	MAIN_E

;--------------

;#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)

INVALID_HANDLE_VALUE EQU -1




;
;3d00	open
;	edx=filename
;	>ax handle
;	>cf=1 : error
INT21_open:

	PUSHAD
	MOV	AL,'['
	CALL	DOS02
	MOV	ESI,EDX
	CALL	_PUTSTR
	MOV	AL,']'
	CALL	DOS02
	CALL	_PUTCRLF
	POPAD

	PUSH	0		;templateFile
	PUSH	FILE_ATTRIBUTE_NORMAL
	PUSH	OPEN_EXISTING	;CREATE_ALWAYS	;CREATE_NEW
	PUSH	0		;securityAttribute
	PUSH	0		;shareMode
	PUSH	GENERIC_READ
	PUSH	EDX		;FILENAME_TEST1
	CALL	[IAT_CreateFileA]
	CMP	EAX,INVALID_HANDLE_VALUE
	JE	INT21_open.ERR

	;MOV	[HDL_INFILE],EAX

	CLC
	RET
INT21_open.ERR:
	STC
	RET

;
;3c00	create
;	edx=filename
;	>ax handle
;	>cf=1 : error

;
INT21_create:

	PUSHAD
	MOV	AL,'['
	CALL	DOS02
	MOV	ESI,EDX
	CALL	_PUTSTR
	MOV	AL,']'
	CALL	DOS02
	CALL	_PUTCRLF
	POPAD

	PUSH	0		;templateFile
	PUSH	FILE_ATTRIBUTE_NORMAL
	PUSH	CREATE_ALWAYS	;CREATE_NEW
	PUSH	0		;securityAttribute
	PUSH	0		;shareMode
	PUSH	GENERIC_WRITE
	PUSH	EDX		;FILENAME_TEST1
	CALL	[IAT_CreateFileA]
	CMP	EAX,INVALID_HANDLE_VALUE
	JE	INT21_create.ERR

	;MOV	[HDL_OUTFILE],EAX

	CLC
	RET
INT21_create.ERR:
	STC
	RET


;#define FILE_BEGIN           0
;#define FILE_CURRENT         1
;#define FILE_END             2

;4200	seek
;	bx=handle
;	cx : dx offset
;
;	> dx : ax current pointer

INT21_seek:
	SHL	ECX,10h
	MOV	CX,DX

	MOVZX	EAX,AL

	PUSH	EAX
	PUSH	0	;size<2GB
	PUSH	ECX
	PUSH	EBX
	CALL	[IAT_SetFilePointer]

	MOV	EDX,EAX
	SHR	EDX,10H
	MOVZX	EAX,AX

	CLC

;erro check?

	RET

INT21_getfilepointer:
	


;
;3f00	read
;	bx=handle
;	edx=buf
;	ecx=bytes
;	>eax read bytes

INT21_read:
	
	PUSH	0
	PUSH	N_READ
	PUSH	ECX
	PUSH	EDX	;READ_BUF
	PUSH	EBX	;[HDL_STDOUT]
	CALL	[IAT_ReadFile]
	OR	EAX,EAX
	JE	INT21_read.ERR

	MOV	EAX,[N_READ]
	CLC
	RET
INT21_read.ERR:
	XOR	EAX,EAX
	STC
	RET

;4000	write
;	bx=handle
;	edx=buf
;	ecx=bytes
;	>eax wrote bytes
;	cf=1 : error	
;
;4000	write/truncate
;	ecx=edx=0
;	bx=handle

INT21_write:
	XOR	EAX,EAX
	MOV	AX,CX
	OR	AX,DX
	JE	INT21_truncate

	PUSH	0
	PUSH	N_WROTE
	PUSH	ECX
	PUSH	EDX	;READ_BUF
	PUSH	EBX	;[HDL_STDOUT]
	CALL	[IAT_WriteFile]
	OR	EAX,EAX
	JE	INT21_write.ERR

	MOV	EAX,[N_WROTE]

	CLC
	RET

INT21_write.ERR:
	XOR	EAX,EAX
	STC
	RET


INT21_truncate:
	PUSH	EBX
	CALL	[IAT_SetEndOfFile]
	RET


;3e00	close
;	bx=handle
;	cf=1 : error
INT21_close:
	PUSH	EBX
	CALL	[IAT_CloseHandle]
	OR	EAX,EAX
	JE	INT21_close.ERR

	CLC
	RET

INT21_close.ERR:
	STC
	RET


;4c	exit
;	al=code

INT21_exit:
	MOVZX	EAX,AL
	PUSH	EAX
	CALL	[IAT_ExitProcess]

	RET


INTE4_putchr:
	MOV	DL,AL
	JMP	INT21_putchr

INT21_putchr:
	MOV	AL,DL
	CALL	_PUTCHR
	RET

INT21_putstr:
	;JMP	_DOS09


	PUSHAD
INT21_putstr.1:
	MOV	AL,[EDX]
	CMP	AL,'$'
	JE	INT21_putstr.2
	PUSH	EDX
	;CALL	DOS02
	MOV	DL,AL
	CALL	INT21_putchr
	POP	EDX
	INC	EDX
	JMP	INT21_putstr.1

INT21_putstr.2:
	POPAD
	RET

;2c
;>ch : hour
;>cl : minute
;>dl : 1/100 seconds

INT21_gettime:

	;TODO
	MOV	CH,0
	MOV	CL,0
	MOV	DL,0

	RET

;0b
;>al 0 : no chr available / ff : chr available
INT21_stdin_status:
	;TODO

	MOV	AL,0
	RET

;01
;>al : chr
INT21_getchr:
	;TODO readfile from hdl_stdin

	MOV	AL,0
	ret

;25
INT21_setinterrupt:

	;dummy

	RET

_DOS09:
;	PUSH	EAX
;	MOV	AH,09H
;	INT	21H
;	POP	EAX

	PUSHAD
_DOS09.1:
	MOV	AL,[EDX]
	CMP	AL,'$'
	JE	_DOS09.R
	PUSH	EDX
	CALL	DOS02
	POP	EDX
	INC	EDX
	JMP	_DOS09.1

_DOS09.R:
	POPAD
	RET

;
;
;
;DOS02:
;	DB	60H
;	MOV	AH,02H
;	MOV	DL,AL
;	INT	21H
;	DB	61H

;	PUSHAD
;	CALL	_PUTCHR
;	POPAD
;	RET

;-----------------------

#INCLUDE <ECDCL.ASM>
#INCLUDE <ECSIZE.ASM>
#INCLUDE <ECMK.ASM>
#INCLUDE <ECMK2.ASM>
#INCLUDE <ECEXP.ASM>
#INCLUDE <ECDEF.ASM>
#INCLUDE <ECTBL.ASM>
#INCLUDE <ECPRE.ASM>
#INCLUDE <ECMISC.ASM>
#INCLUDE <ECSUB.ASM>



;################
;	ds	1000h

_TEXT_FILL:
	;ds	HEADER+0600h-$
	ALIGN	FILE_ALIGN	;200h

;#define STD_INPUT_HANDLE    ((DWORD)-10)
;#define STD_OUTPUT_HANDLE   ((DWORD)-11)
;#define STD_ERROR_HANDLE    ((DWORD)-12)

_TEXT_END:

;------------------------------------

_RDATA:

;+600	".rdata" ->2000h-

;<- #c IMAGE_DIRECTORY_ENTRY_IAT
;<- 0:FirstThunk

;Import Address Table
ENTRY_IAT:

IAT_GetStdHandle:
;IAT_GetStdHandle EQU $-_RDATA+_RDATA_RVA+BASE
	DD	ENTRY_GetStdHandle-_RDATA+_RDATA_RVA	;0000204ch	;DW	0264h / DB	"GetStdHandle",0
IAT_WriteFile:
	DD	ENTRY_WriteFile-_RDATA+_RDATA_RVA	;00002040h	;DW	0525h /	DB	"WriteFile", 0
IAT_ReadFile:
	DD	ENTRY_ReadFile-_RDATA+_RDATA_RVA
IAT_CreateFileA:
	DD	ENTRY_CreateFileA-_RDATA+_RDATA_RVA
IAT_CloseHandle:
	DD	ENTRY_CloseHandle-_RDATA+_RDATA_RVA
IAT_ExitProcess:
	DD	ENTRY_ExitProcess-_RDATA+_RDATA_RVA
IAT_GetCommandLineA:
	DD	ENTRY_GetCommandLineA-_RDATA+_RDATA_RVA
IAT_SetFilePointer:
	DD	ENTRY_SetFilePointer-_RDATA+_RDATA_RVA
IAT_SetEndOfFile:
	DD	ENTRY_SetEndOfFile-_RDATA+_RDATA_RVA
IAT_GlobalAlloc:
	DD	ENTRY_GlobalAlloc-_RDATA+_RDATA_RVA
IAT_GlobalFree:
	DD	ENTRY_GlobalFree-_RDATA+_RDATA_RVA

	DD	00000000h

ENTRY_IAT_END:

;<- #1 IMAGE_DIRECTORY_ENTRY_IMPORT

ENTRY_IMPORT:
;+60c	(200ch)
	DD	ENTRIES_0-_RDATA+_RDATA_RVA	;00002034h	;Characteristics
;+610
	DD	00000000h	;TimeDateStamp
	DD	00000000h	;ForwarderChain
	DD	DLLNAME_KERNEL32-_RDATA+_RDATA_RVA	;0000205ch	;Name = "KERNEL32.dll", 0
	DD	_RDATA_RVA	;00002000h	;FirstThunk
						;== ENTRY_IAT-_RDATA+_RDATA_RVA
;+620
	DD	00000000h	;Characteristics
	DD	00000000h
	DD	00000000h
	DD	00000000h
;+630
	DD	00000000h	;FirstThunk
ENTRY_IMPORT_END:

ENTRIES_0:
;+634	(2034h) <- 0:Characteristics
	DD	ENTRY_GetStdHandle-_RDATA+_RDATA_RVA	;0000204ch	;DW	0264h / DB	"GetStdHandle",0
	DD	ENTRY_WriteFile-_RDATA+_RDATA_RVA	;00002040h	;DW	0525h / DB	"WriteFile", 0
	DD	ENTRY_ReadFile-_RDATA+_RDATA_RVA
	DD	ENTRY_CreateFileA-_RDATA+_RDATA_RVA
	DD	ENTRY_CloseHandle-_RDATA+_RDATA_RVA
	DD	ENTRY_ExitProcess-_RDATA+_RDATA_RVA
	DD	ENTRY_GetCommandLineA-_RDATA+_RDATA_RVA
	DD	ENTRY_SetFilePointer-_RDATA+_RDATA_RVA
	DD	ENTRY_SetEndOfFile-_RDATA+_RDATA_RVA
	DD	ENTRY_GlobalAlloc-_RDATA+_RDATA_RVA
	DD	ENTRY_GlobalFree-_RDATA+_RDATA_RVA

	DD	00000000h


ENTRY_GlobalFree:
	DW	0
	DB	"GlobalFree",0
	ALIGN	4

ENTRY_GlobalAlloc:
	DW	0
	DB	"GlobalAlloc",0
	ALIGN	4

ENTRY_SetEndOfFile:
	DW	0
	DB	"SetEndOfFile", 0
	ALIGN	4

ENTRY_SetFilePointer:
	DW	0
	DB	"SetFilePointer", 0
	ALIGN	4

ENTRY_GetCommandLineA:
	DW	0
	DB	"GetCommandLineA", 0
	ALIGN	4

ENTRY_ExitProcess:
	DW	0
	DB	"ExitProcess",0
	ALIGN	4

ENTRY_CloseHandle:
	DW	0
	DB	"CloseHandle", 0
	ALIGN	4

ENTRY_CreateFileA:
	DW	0
	DB	"CreateFileA", 0
	ALIGN	4

ENTRY_ReadFile:
	DW	0
	DB	"ReadFile", 0
	ALIGN	4

;+640	(2040h)
ENTRY_WriteFile:
	DW	0525h
	DB	"WriteFile", 0

;+64c	(204ch)
ENTRY_GetStdHandle:
	DW	0264h
	DB	"GetStdHandle",0
	DB	0

;+65c	(205ch)
DLLNAME_KERNEL32:
	DB	"KERNEL32.dll", 0
	DB	0,0,0


;//
;// Debug Format
;//
;
;typedef struct _IMAGE_DEBUG_DIRECTORY {
;    DWORD   Characteristics;
;    DWORD   TimeDateStamp;
;    WORD    MajorVersion;
;    WORD    MinorVersion;
;    DWORD   Type;
;    DWORD   SizeOfData;
;    DWORD   AddressOfRawData;
;    DWORD   PointerToRawData;
;} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

IMAGE_DEBUG_TYPE_COFF	EQU             1

	ALIGN	32

ENTRY_DEBUG:
__IMAGE_DEBUG_DIRECTORY__:
	DD	0	;Characteristics
	DD	529037aeh	;TimeDateStamp
	DW	0	;MajorVersion
	DW	0	;MinorVersion
	DD	IMAGE_DEBUG_TYPE_COFF	;Type

	;DD	_DEBUG_END-_DEBUG_HEADER1 ;-18	;SizeOfData;
	;DD	_DEBUG_FILL-_DEBUG_HEADER1 ;-18	;SizeOfData;
	DD	_DEBUG_NAME_END-_DEBUG_HEADER1

	DD	0  ;_DEBUG_HEADER1-_DEBUG+_DEBUG_RVA	;AddressOfRawData
	;DD	_DEBUG_HEADER1-_DEBUG;-BASE	;PointerToRawData
	DD	_DEBUG_HEADER1-BASE
	;DD	0ff000000h

;
;http://msdn.microsoft.com/en-us/library/windows/desktop/ms680307%28v=vs.85%29.aspx
;
;SizeOfData
;    The size of the debugging information, in bytes. This value does not include the debug directory itself.
;
;AddressOfRawData
;    The address of the debugging information when the image is loaded, relative to the image base.
;
;PointerToRawData
;    A file pointer to the debugging information.


;IMAGE_DEBUG_DIRECTORY	size=1ch

;---------


_RDATA_FILL:
	;ds	HEADER+0800h-$
	ALIGN	FILE_ALIGN	;200h

_RDATA_END:

;-----------------------

_DATA:

;+800	".data" ->3000h-

STR_HELLO:
	DB	"Hello, World!", 0ah, 0

FILENAME_TEST1:
	DB	"CreateFileTest.txt", 0

	ALIGN	4

N_WROTE:DD	0

HDL_STDIN:DD	0
HDL_STDOUT:DD	0
HDL_STDERR:DD	0

HDL_OUTFILE:DD	0

N_READ:DD	0

PUTCHR_BUF:DS	1

CMDLINE:ds	4

READ_BUF:	ds	200

;USRDMA:

#INCLUDE <ECDATA.ASM>

;-----------------------------------




	;END



_DATA_FILL:
	;ds	HEADER+0a00h-$
	ALIGN	FILE_ALIGN	;200h

_DATA_END:

;---------------------------

;_RELOC:
;
;;+a00	".reloc" ->4000h-
;
;	dd	_TEXT_RVA	;00001000h
;	dd	00000010h
;	dw	0,0,0,0
;
;	;db	00h,10h,00h,00h, 10h,00h,00h,00h
;	;db	04h,30h,0fh,30h, 16h,30h,00h,00h
;	;db	0,0,0,0, 0,0,0,0
;
;	;dd	00001000h
;	;dd	00000010h
;	;DW	3004h, 300fh, 3016h, 0000h
;	;==DW	0004h | 3<<12, 000fh | 3<<12, 0016h | 3<<12, 0 | 0<<12
;
;0 IMAGE_REL_BASED_ABSOLUTE
;2 IMAGE_REL_BASED_HIGHLOW

;_RELOC_FILL:
;	;ds	HEADER+0c00h-$
;	ALIGN	FILE_ALIGN	;200h
;
;_RELOC_END:

HEADER_END:

;	CLI
;	mov	esp,40000h
;	STI
;	CLD

;	CALL	GETCLINE

;	MOV	EAX,DS
;	MOV	ES,EAX

;	MOV	ESI,CLINE+1
;	MOV	EDI,FILE1
;	CALL	STRCPY




	ALIGN FILE_ALIGN




;NumberOfSymbols
;    The number of symbols.
;LvaToFirstSymbol
;    The virtual address of the first symbol.
;NumberOfLinenumbers
;    The number of line-number entries.
;LvaToFirstLinenumber
;    The virtual address of the first line-number entry.
;RvaToFirstByteOfCode
;    The relative virtual address of the first byte of code.
;RvaToLastByteOfCode
;    The relative virtual address of the last byte of code.
;RvaToFirstByteOfData
;    The relative virtual address of the first byte of data.
;RvaToLastByteOfData
;    The relative virtual address of the last byte of data.

;+1c
;IMAGE_COFF_SYMBOLS_HEADER
_DEBUG_HEADER1:
	DD	4	;NumberOfSymbols
	DD	_SYM1-_DEBUG_HEADER1	;LvaToFirstSymbol
	DD	0	;NumberOfLinenumbers
	DD	0	;LvaToFirstLinenumber

	DD	_TEXT_RVA	;RvaToFirstByteOfCode
	DD	_TEXT_END-1-_TEXT+_TEXT_RVA	;RvaToLastByteOfCode
	DD	_DATA_RVA	;RvaToFirstByteOfData
	DD	_DATA_END-1-_DATA+_DATA_RVA	;RvaToLastByteOfData


;	dd	3dh
;	dd	0020h
;	dd	0
;	dd	0

;	dd	00001000h
;	dd	00001200h
;	dd	00002000h
;	dd	00001400h


;//
;// Symbol format.
;//
;
;typedef struct _IMAGE_SYMBOL {
;    union {
;        BYTE    ShortName[8];
;        struct {
;            DWORD   Short;     // if 0, use LongName
;            DWORD   Long;      // offset into string table
;        } Name;
;        DWORD   LongName[2];    // PBYTE [2]
;    } N;
;    DWORD   Value;
;    SHORT   SectionNumber;
;    WORD    Type;
;    BYTE    StorageClass;
;    BYTE    NumberOfAuxSymbols;
;} IMAGE_SYMBOL;
;typedef IMAGE_SYMBOL UNALIGNED *PIMAGE_SYMBOL;

;#define IMAGE_SIZEOF_SYMBOL                  18


;//
;// Section values.
;//
;// Symbols have a section number of the section in which they are
;// defined. Otherwise, section numbers have the following meanings:
;//
;
;#define IMAGE_SYM_UNDEFINED           (SHORT)0          // Symbol is undefined or is common.
;#define IMAGE_SYM_ABSOLUTE            (SHORT)-1         // Symbol is an absolute value.
;#define IMAGE_SYM_DEBUG               (SHORT)-2         // Symbol is a special debug item.
;#define IMAGE_SYM_SECTION_MAX         0xFEFF  

;IMAGE_SYM_UNDEFINED 0 Symbol record is not yet assigned a section. If the value
;is 0 this indicates a references to an external symbol
;defined elsewhere. If the value is non-zero this is a
;common symbol with a size specified by the value.

_SYM1:
	DB	'header',0,0	;ShortName
	DD	0	;Value
	DW	-2	;SectionNumber
	DW	0	;Type
	DB	2	;StorageClass
	DB	0	;NumberOfAuxSymbols
_DEBUG_NAME_END:

	DB	'_start',0,0	;ShortName
	DD	00001000h	;Value
	DW	1	;SectionNumber
	DW	0	;Type
	DB	2	;StorageClass
	DB	0	;NumberOfAuxSymbols

	DB	'hogehoge'
	DD	12345678h;00001000h	;Value
	DW	1	;SectionNumber
	DW	0	;Type
	DB	2	;StorageClass
	DB	0	;NumberOfAuxSymbols



	DB	'end',0, 0,0,0,0
	DD	4000h
	DW	-2
	DW	0
	DB	2
	DB	0


;SYM2_END:

;01B 00000000 DEBUG  notype       External     | header
;01C 00001000 SECT1  notype ()    External     | _start
;03C 00004000 DEBUG  notype       External     | end

	ds	700h






